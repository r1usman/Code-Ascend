"[\"(n, mod, tot, loc) = (input().strip(), 10 ** 9 + 7, 0, 0)\\nfor (i, c) in enumerate(n[::-1]):\\n\\tp = len(n) - 1 - i\\n\\ttot = (tot + p * (p + 1) // 2 * int(c) * pow(10, i, mod) + loc * int(c)) % mod\\n\\tloc = (loc + (i + 1) * pow(10, i, mod)) % mod\\nprint(tot % mod)\\n\", \"import math\\nbign = 1000000007\\na = input()\\nn = len(a)\\ng = [1] * n\\ngc = [1] * (n + 1)\\ngc[-1] = 0\\nh = [1] * (n + 1)\\nh[-1] = 0\\nhc = [1] * (n + 1)\\nhc[-1] = 0\\nfor i in range(1, n):\\n\\tg[i] = g[i - 1] * 10 % bign\\n\\th[i] = h[i - 1] * (i + 1) % bign\\n\\tgc[i] = (gc[i - 1] + (i + 1) * g[i]) % bign\\n\\thc[i] = (hc[i - 1] + (i + 1)) % bign\\nans = 0\\nfor i in range(n):\\n\\tans += int(a[i]) * gc[n - 2 - i] % bign\\n\\tans %= bign\\n\\tans += int(a[i]) * g[n - 1 - i] * hc[i - 1] % bign\\n\\tans %= bign\\nprint(ans)\\n\", \"Mod = 10 ** 9 + 7\\nT = str(input())\\nn = len(T)\\nsubstring = [0 for i in range(n)]\\npow10 = [0 for j in range(n)]\\npow10[0] = 1\\nfor i in range(1, n):\\n\\tpow10[i] = pow10[i - 1] * 10 % Mod\\nfor i in range(n - 1):\\n\\tsubstring[n - i - 2] = (substring[n - i - 1] + pow10[i] * (i + 1)) % Mod\\ncount = 0\\nfor i in range(n):\\n\\ttotal_string = i * (i + 1) / 2 % Mod\\n\\tcontribution1 = int(total_string) * (int(T[i]) % Mod * pow10[n - i - 1]) % Mod\\n\\tcontribution2 = int(T[i]) % Mod * substring[i] % Mod\\n\\tcount += contribution1 + contribution2\\nprint(int(count) % Mod)\\n\", \"s = input()\\nM = 10 ** 9 + 7\\no = u = v = i = 0\\nn = len(s)\\nfor c in s:\\n\\tc = int(c)\\n\\tu += v\\n\\tv = (10 * v + c) % M\\n\\to += pow(10, n - i - 1, M) * ((i * i + i) // 2 * c + u)\\n\\ti += 1\\nprint(o % M)\\n\", \"import sys\\nimport math as mt\\nimport bisect\\nt = 1\\np = 10 ** 9 + 7\\nfact = [0] * 300001\\ninv = [0] * 300001\\n\\ndef ncr_util():\\n\\tinv[0] = inv[1] = 1\\n\\tfact[0] = fact[1] = 1\\n\\tfor i in range(2, 300001):\\n\\t\\tinv[i] = inv[i % p] * (p - p // i) % p\\n\\tfor i in range(1, 300001):\\n\\t\\tinv[i] = inv[i - 1] * inv[i] % p\\n\\t\\tfact[i] = fact[i - 1] * i % p\\nncr_util()\\n\\ndef ncr(n, r):\\n\\treturn fact[n] * inv[n - r] % p * (inv[r] % p) % p\\n\\ndef solve():\\n\\tans = 0\\n\\tp2 = [1] * (len(s) + 1)\\n\\tp10 = [1] * (len(s) + 1)\\n\\tp11 = [1] * (len(s) + 1)\\n\\tmul = 1\\n\\tfor i in range(1, len(s) + 1):\\n\\t\\tp2[i] = p2[i - 1] * 2 % p\\n\\t\\tp10[i] = p10[i - 1] * 10 % p\\n\\t\\tp11[i] = p11[i - 1] * 10 % p\\n\\tpref = [0] * (len(s) + 1)\\n\\tmul = 1\\n\\tfor i in range(1, len(s) + 1):\\n\\t\\tpref[i] = (pref[i - 1] + i * mul % p) % p\\n\\t\\tmul = mul * 10 % p\\n\\tfor i in range(len(s)):\\n\\t\\tx = int(s[i])\\n\\t\\tx1 = i\\n\\t\\tx1 = x1 * (x1 + 1) // 2\\n\\t\\ty1 = x * pref[len(s) - i - 1] % p\\n\\t\\tx1 = x * x1 % p * p10[len(s) - i - 1] % p\\n\\t\\tans = (ans + x1 + y1) % p\\n\\treturn ans\\nfor _ in range(t):\\n\\ts = input()\\n\\tprint(solve())\\n\", \"s = input()\\nmod = int(1000000000.0 + 7)\\nl = len(s)\\n(a, b) = (0, 0)\\nss = s[::-1]\\nfor i in range(l):\\n\\tc = int(ss[i])\\n\\tp = l - 1 - i\\n\\ta += p * (p + 1) // 2 * c * pow(10, i, mod)\\n\\ta += b * c\\n\\ta %= mod\\n\\tb += (i + 1) * pow(10, i, mod)\\n\\tb %= mod\\nprint(a)\\n\", \"MOD = 1000000007\\n\\ndef power(a, b, m):\\n\\tans = 1\\n\\tfor i in range(b):\\n\\t\\tans = ans * a % m\\n\\treturn ans\\ns = input()\\nn = len(s)\\npower10 = []\\nrev = []\\nfor i in range(n):\\n\\tif i == 0:\\n\\t\\tpower10.append(1)\\n\\t\\trev.append(1)\\n\\telse:\\n\\t\\tpower10.append(power10[i - 1] * 10 % MOD)\\n\\t\\trev.append(((i + 1) * power10[i] + rev[i - 1]) % MOD)\\nans = 0\\nfor i in range(n):\\n\\tno = int(s[i])\\n\\tif no == 0:\\n\\t\\tcontinue\\n\\tld = i\\n\\trd = int(n - ld - 1)\\n\\tlans = 0\\n\\trans = 0\\n\\tif ld != 0:\\n\\t\\tlans = ld * (ld + 1) // 2 % MOD\\n\\t\\tlans = lans * power10[rd] % MOD\\n\\t\\tlans = lans * no % MOD\\n\\tif rd != 0:\\n\\t\\trans = rev[rd - 1] * no % MOD\\n\\tans += int(lans + rans)\\nprint(ans % MOD)\\n\", \"s = input()\\nn = len(s)\\nmod = int(1000000000.0 + 7)\\nfans = 0\\nvals = [0]\\np10 = 1\\nfor i in range(1, n + 2):\\n\\tvals.append(vals[-1] + p10 * i % mod)\\n\\tp10 *= 10\\n\\tp10 %= mod\\n\\tvals[-1] %= mod\\nfor (i, a) in zip(range(n), s):\\n\\td = int(a)\\n\\ton_left = i\\n\\ton_right = n - i - 1\\n\\tfans += on_left * (on_left + 1) // 2 % mod * d * pow(10, n - i - 1, mod) % mod\\n\\tb = n - i - 1\\n\\tx = on_right - 1\\n\\tvv = vals[on_right] * d\\n\\tfans += vv % mod\\n\\tfans %= mod\\nprint(int(fans))\\n\", \"import math\\nmod = 10 ** 9 + 7\\n\\ndef modInverse(b):\\n\\treturn pow(b, mod - 2, mod)\\n\\ndef modDivide(a, b):\\n\\ta = a % mod\\n\\tinv = modInverse(b)\\n\\treturn inv * a % mod\\n\\ndef solve():\\n\\tarr = list(map(int, list(input())))\\n\\tif len(arr) == 1:\\n\\t\\tprint(0)\\n\\t\\treturn 0\\n\\tt = 0\\n\\tl = len(arr)\\n\\tR = 0\\n\\tfor i in range(l - 2, -1, -1):\\n\\t\\tR += pow(10, l - i - 1 - 1, mod) * (l - i - 1) % mod\\n\\t\\tR %= mod\\n\\t\\tt += arr[i] * R % mod\\n\\t\\tt %= mod\\n\\tfor i in range(1, l):\\n\\t\\tt += arr[i] * (i * (i + 1) // 2) % mod * pow(10, l - i - 1, mod) % mod\\n\\t\\tt %= mod\\n\\tprint(int(t) % mod)\\nsolve()\\n\", \"import os\\nimport sys\\nfrom io import BytesIO, IOBase\\nimport threading\\nfrom bisect import bisect_right\\nfrom math import gcd, log\\nfrom collections import defaultdict\\nfrom pprint import pprint\\nfrom math import ceil\\nMOD = 10 ** 9 + 7\\n\\ndef main():\\n\\ts = input()\\n\\tsu = 0\\n\\tsm = 0\\n\\tn = len(s)\\n\\tarr = [0] * n\\n\\tnum = 0\\n\\tfor i in range(n):\\n\\t\\tdig = int(s[i])\\n\\t\\tnum = num * 10 + dig\\n\\t\\tnum %= MOD\\n\\t\\tsm = sm + num\\n\\t\\tsm %= MOD\\n\\t\\tarr[i] = sm\\n\\tcnt = 0\\n\\tans = 0\\n\\tdig = 0\\n\\ttp = 1\\n\\tfor i in range(n - 1, -1, -1):\\n\\t\\tans = ans + dig * (i + 1) + tp * arr[i]\\n\\t\\tdig = dig + tp * int(s[i])\\n\\t\\tans += dig\\n\\t\\ttp *= 10\\n\\t\\ttp %= MOD\\n\\t\\tans %= MOD\\n\\tans = ans - dig * (n + 1)\\n\\tans %= MOD\\n\\tprint(ans)\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nfor _ in range(1):\\n\\tmain()\\n\", \"s = str(input())\\nbase = 1000000007\\nn = len(s)\\nf = [0] * (n + 1)\\nfor i in range(1, n + 1):\\n\\tf[i] = i * (i + 1) // 2\\nt = [1] * (n + 1)\\nt[0] = 1\\nfor i in range(1, n + 1):\\n\\tt[i] = t[i - 1] * 10 % base\\np = [0] * (n + 1)\\nfor i in range(1, n):\\n\\tp[i] = (i * t[i - 1] % base + p[i - 1]) % base\\nans = 0\\nfor i in range(n - 1, -1, -1):\\n\\tans = (ans + int(s[i]) * f[i] * t[n - i - 1] % base + int(s[i]) * p[n - 1 - i] % base) % base\\nprint(ans)\\n\", \"n = list(input())\\nl = len(n)\\nx = 1\\ny = 0\\nz = 0\\nmod = pow(10, 9) + 7\\nans = 0\\nfor i in range(l):\\n\\tm = int(n[l - i - 1])\\n\\tans += x * m * ((l - i) * (l - i - 1) // 2)\\n\\tans %= mod\\n\\tans += z * m\\n\\tans %= mod\\n\\ty += 1\\n\\tz += x * y\\n\\tz %= mod\\n\\tx *= 10\\n\\tx %= mod\\nprint(ans)\\n\", \"def isSubsetSum(set, n, sum):\\n\\tif sum == 0:\\n\\t\\treturn True\\n\\tif n == 0 and sum != 0:\\n\\t\\treturn False\\n\\tif set[n - 1] > sum:\\n\\t\\treturn isSubsetSum(set, n - 1, sum)\\n\\treturn isSubsetSum(set, n - 1, sum) or isSubsetSum(set, n - 1, sum - set[n - 1])\\nmod = 10 ** 9 + 7\\nres = 0\\nvect = 0\\nstring = input()\\nstring = string[::-1]\\nn = len(string)\\nfor (i, dx) in enumerate(string):\\n\\td = int(dx)\\n\\tres += pow(10, i, mod) * d * (((n - i - 1) * (n - i - 2) // 2 + (n - i - 1)) % mod)\\n\\tres %= mod\\n\\tif i > 0:\\n\\t\\tvect += i * pow(10, i - 1, mod)\\n\\tvect %= mod\\n\\tres += d * vect\\n\\tres %= mod\\nprint(res)\\n\", \"mod = 1000000007\\ns = list(map(int, input()))\\nn = len(s)\\npost = n * (n - 1) // 2 % mod\\npre = 0\\nans = 0\\npos = 1\\nfor i in range(n):\\n\\tans = (ans + pre * s[n - i - 1]) % mod\\n\\tans = (ans + post * pos * s[n - i - 1]) % mod\\n\\tpre = (pre + (i + 1) * pos) % mod\\n\\tpost = (post - (n - i - 1)) % mod\\n\\tpos = pos * 10 % mod\\nprint(ans % mod)\\n\", \"a = input()\\nln = len(a)\\nans = 0\\nmod = 10 ** 9 + 7\\nmul = [0] * ln\\nprev = 1\\npow10 = [1] * ln\\nfor i in range(ln):\\n\\tmul[i] = prev * (i + 1)\\n\\tif i > 0:\\n\\t\\tmul[i] += mul[i - 1]\\n\\t\\tpow10[i] = pow10[i - 1] * 10\\n\\t\\tpow10[i] %= mod\\n\\tmul[i] %= mod\\n\\tprev *= 10\\n\\tprev %= mod\\nans = 0\\nfor i in range(ln):\\n\\tcur = i * (i + 1) // 2\\n\\tcur *= int(a[i])\\n\\tcur %= mod\\n\\tcur *= pow10[ln - i - 1]\\n\\tans += cur % mod\\n\\tif i < ln - 1:\\n\\t\\tans += int(a[i]) * mul[ln - i - 2] % mod\\n\\tans %= mod\\nprint(ans % mod)\\n\", \"from sys import stdin, stdout\\nfrom math import gcd, sqrt, factorial, pi, inf\\nfrom collections import deque, defaultdict\\ninput = stdin.readline\\nR = lambda : map(int, input().split())\\nI = lambda : int(input())\\nS = lambda : input().rstrip('\\\\n')\\nL = lambda : list(R())\\nP = lambda x: stdout.write(x)\\nlcm = lambda x, y: x * y // gcd(x, y)\\nhg = lambda x, y: (y + x - 1) // x * x\\npw = lambda x: 1 if x == 1 else 1 + pw(x // 2)\\nchk = lambda x: chk(x // 2) if not x % 2 else True if x == 1 else False\\nsm = lambda x: (x ** 2 + x) // 2\\nN = 10 ** 9 + 7\\n(*a,) = map(int, S())\\nsm = 0\\nval = 0\\npst = 0\\nans = 0\\nn = len(a)\\nfor i in range(n):\\n\\tans *= 10\\n\\tans += sm - val\\n\\tans += (i ** 2 + i) // 2 * a[i]\\n\\tsm += a[i] * (n - i - 1)\\n\\tval += pst\\n\\tpst += a[i]\\n\\tans %= N\\nprint(ans)\\n\", \"import sys\\nnum = input()\\nn = len(num)\\nans = 0\\nmd = 1000000007\\ncc = [0]\\nten = [1]\\nfor i in range(n + 1):\\n\\tten.append(ten[-1] * 10 % md)\\n\\tcc.append((cc[-1] + ten[i] * (i + 1)) % md)\\nfor (i, a) in enumerate(num):\\n\\ta = int(a)\\n\\tans += a * (cc[n - i - 1] + ten[n - i - 1] * i * (i + 1) // 2)\\n\\tans %= md\\nprint(ans)\\n\", \"import sys\\ninput = sys.stdin.readline\\nm = 10 ** 9 + 7\\nn = input().strip('\\\\n')\\na = [int(i) for i in n]\\nn = len(n)\\ntable = []\\ns = 0\\nfor i in range(n):\\n\\ts = (s + (i + 1) * pow(10, i, m)) % m\\n\\ttable.append(s)\\ns = 0\\nfor i in range(n):\\n\\tx = n - i - 2\\n\\tif x >= 0:\\n\\t\\ts += a[i] * table[x]\\n\\ts += i * (i + 1) // 2 * a[i] * pow(10, x + 1, m)\\n\\ts = s % m\\nprint(s)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\ndef getInts():\\n\\treturn [int(s) for s in input().split()]\\n\\ndef getInt():\\n\\treturn int(input())\\n\\ndef getStrs():\\n\\treturn [s for s in input().split()]\\n\\ndef getStr():\\n\\treturn input().strip()\\n\\ndef listStr():\\n\\treturn list(input().strip())\\nimport collections as col\\nimport math\\nM = 10 ** 9 + 7\\n\\ndef triangle(j):\\n\\treturn j * (j + 1) // 2 % M\\n\\ndef solve():\\n\\tN = [int(s) for s in input().strip()]\\n\\tlen_N = len(N)\\n\\tten_pows = col.defaultdict(int)\\n\\tten_pows[0] = 1\\n\\tfor j in range(1, len_N + 1):\\n\\t\\tten_pows[j] = ten_pows[j - 1] * 10 % M\\n\\tP = [N[0]]\\n\\tcurr = N[0]\\n\\tfor j in range(1, len_N):\\n\\t\\tcurr += N[j]\\n\\t\\tcurr %= M\\n\\t\\tP.append(curr)\\n\\tans = 0\\n\\tfor j in range(1, len_N):\\n\\t\\ttmp = (P[j - 1] * (len_N - j) + triangle(j) * N[j]) * ten_pows[len_N - j - 1]\\n\\t\\tans += tmp\\n\\t\\tans %= M\\n\\treturn ans\\nprint(solve())\\n\", \"n = list(map(int, list(input())))\\nl = len(n)\\nMOD = int(1000000000.0 + 7)\\nk = [pow(10, l - 1 - i, MOD) for i in range(l)]\\ns = [0]\\nfor i in range(l - 1):\\n\\ts.append(s[-1])\\n\\ts[-1] += (i + 1) * k[l - i - 1]\\n\\ts[-1] %= MOD\\nprint(sum([(d * k[i] * i * (i + 1) // 2 + d * s[l - 1 - i]) % MOD for (i, d) in enumerate(n)]) % MOD)\\n\", \"s = input()\\nans = 0\\nmod = 10 ** 9 + 7\\nsufix = [0 for x in range(len(s))]\\nsufix[0] = 1\\nn = len(s)\\nten = [1 for x in range(n + 1)]\\nfor i in range(1, n + 1):\\n\\tten[i] = ten[i - 1] * 10\\n\\tten[i] %= mod\\nfor i in range(len(s)):\\n\\tsufix[i] = ten[i] * (i + 1) + sufix[i - 1]\\nsufix = sufix[-1::-1]\\nsufix.append(0)\\nfor i in range(len(s)):\\n\\tans += i * (i + 1) // 2 * int(s[i]) * ten[n - i - 1]\\n\\tans %= mod\\n\\tans += int(s[i]) * sufix[i + 1]\\n\\tans %= mod\\nprint(ans)\\n\", \"MOD = 10 ** 9 + 7\\n\\ndef precompute_Mc(N):\\n\\tres = [0]\\n\\tcurrent = 1\\n\\ts = 2\\n\\tfor i in range(N):\\n\\t\\tres.append(current)\\n\\t\\tcurrent += s\\n\\t\\ts += 1\\n\\treturn res\\n\\ndef precompute_Ms(N):\\n\\tres = []\\n\\tcurrent = 1\\n\\tfor i in range(N):\\n\\t\\tres.append(current)\\n\\t\\tcurrent *= 10\\n\\t\\tcurrent %= MOD\\n\\treturn res\\n\\ndef precompute_Mp(N, Ms):\\n\\tres = [0]\\n\\tfor i in range(N):\\n\\t\\tres.append((res[-1] + Ms[i] * (i + 1)) % MOD)\\n\\treturn res\\ns = input()\\ns = s[::-1]\\nN = len(s)\\nMc = precompute_Mc(N)\\nMs = precompute_Ms(N)\\nMp = precompute_Mp(N, Ms)\\nlastAr = 0\\nanswer = 0\\nfor i in range(N):\\n\\tc = int(s[i]) * Mc[N - i - 1] * Ms[i] % MOD\\n\\td = int(s[i]) * Mp[i] % MOD\\n\\tanswer += c\\n\\tanswer += d\\n\\tanswer %= MOD\\nprint(answer)\\n\", \"import os\\nimport sys\\nfrom io import BytesIO, IOBase\\nmod = 10 ** 9 + 7\\n\\ndef main():\\n\\ts = list(map(int, input()))\\n\\tpre = 1\\n\\tn = len(s)\\n\\tans = n * (n - 1) // 2 * s[-1]\\n\\tp = 1\\n\\tfor i in range(n - 2, -1, -1):\\n\\t\\tp = p * 10 % mod\\n\\t\\tif s[i]:\\n\\t\\t\\tz = i * (i + 1) // 2 % mod\\n\\t\\t\\tans = (ans + z * p * s[i] + pre * s[i]) % mod\\n\\t\\tpre = (pre + p * (n - i)) % mod\\n\\tprint(ans)\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nmain()\\n\", \"n = input()[::-1]\\nm = len(n)\\ncount = 0\\nmod = 10 ** 9 + 7\\n\\ndef egcd(a, b):\\n\\tif a == 0:\\n\\t\\treturn (b, 0, 1)\\n\\telse:\\n\\t\\t(g, y, x) = egcd(b % a, a)\\n\\t\\treturn (g, x - b // a * y, y)\\n\\ndef modinv(a, m):\\n\\t(g, x, y) = egcd(a, m)\\n\\tif g != 1:\\n\\t\\traise Exception('modular inverse does not exist')\\n\\telse:\\n\\t\\treturn x % m\\nzz = modinv(9 ** 2, mod)\\nzzz = modinv(9, mod)\\nfor i in range(0, m):\\n\\tif n[i] == '0':\\n\\t\\tcontinue\\n\\tp = int(n[i])\\n\\tppp = pow(10, i, mod)\\n\\tcount += p * ppp * ((m - i - 1) * (m - i) // 2)\\n\\tcount = count % mod\\n\\tsumt = 0\\n\\tif i > 0:\\n\\t\\tsumt = p * (((i - 1) * (ppp * 10) % mod - i * ppp + 10) * zz) % mod\\n\\t\\tsumt += p * ((ppp - 1) * zzz) % mod\\n\\tcount = (count + sumt) % mod\\nprint(int(count))\\n\", \"s = input()\\nn = len(s)\\ndp = []\\n(cur, pw) = (0, 1)\\nmod = int(1000000000.0 + 7)\\nfor i in range(1, n + 1):\\n\\tcur = (cur + i * pw) % mod\\n\\tpw = pw * 10 % mod\\n\\tdp.append(cur)\\nans = 0\\nfor (i, x) in enumerate(s):\\n\\tk = n - 2 - i\\n\\tif k >= 0:\\n\\t\\tans += dp[k] * int(x)\\n\\tans += i * (i + 1) // 2 * int(x) * pow(10, n - i - 1, mod)\\n\\tans %= mod\\nprint(ans)\\n\", \"from sys import stdin\\nN = stdin.readline().strip()\\nans = 0\\nmult = 0\\nlength = len(N)\\nbuffer = 1\\ntimes = length * (length - 1) // 2\\nk = 0\\nfor i in range(length - 1, -1, -1):\\n\\tj = int(N[i])\\n\\tans += j * mult\\n\\tans += j * buffer * times\\n\\ttimes -= i\\n\\tmult += buffer * (k + 1)\\n\\tk += 1\\n\\tbuffer %= 10 ** 9 + 7\\n\\tbuffer *= 10\\n\\tk %= 10 ** 9 + 7\\n\\tmult %= 10 ** 9 + 7\\nprint(ans % (10 ** 9 + 7))\\n\", \"s = input()[::-1]\\nM = 10 ** 9 + 7\\nr = 0\\nn = len(s)\\ncumu = 0\\nd10 = 1\\nfor d in range(n):\\n\\tx = int(s[d])\\n\\tg = n - 1 - d\\n\\tds = d10 * x * (g * (g + 1)) // 2\\n\\tds += cumu * x\\n\\tr += ds\\n\\tcumu += (d + 1) * d10\\n\\td10 = d10 * 10\\n\\td10 = d10 % M\\n\\tcumu = cumu % M\\n\\tr = r % M\\nprint(r % M)\\n\", \"n = input()\\nm = len(n)\\nM = int(1000000000.0) + 7\\ns = 0\\nans = 0\\nfor (i, c) in enumerate(n):\\n\\tx = int(c)\\n\\ta = s * (m - i) % M\\n\\tb = x * (i * (i + 1) // 2 % M) % M\\n\\tans = (ans + pow(10, m - i - 1, M) * (a + b)) % M\\n\\ts = (s + x) % M\\nprint(ans)\\n\", \"from math import ceil\\nfrom collections import defaultdict\\n\\ndef solve():\\n\\ts = input()\\n\\tn = len(s)\\n\\tplace = 0\\n\\tdp = [0] * (n + 1)\\n\\tdp[1] = 0\\n\\tsum = int(s[0])\\n\\tmod = 10 ** 9 + 7\\n\\tha = sum\\n\\tfor i in range(2, n + 1):\\n\\t\\tz = int(s[i - 1])\\n\\t\\tdp[i] = dp[i - 1] * 10 + (i - 1) * i * z // 2 + ha\\n\\t\\tdp[i] %= mod\\n\\t\\tsum = sum * 10 + z\\n\\t\\tsum %= mod\\n\\t\\tha += sum\\n\\t\\tha %= mod\\n\\tprint(dp[n] % mod)\\nsolve()\\n\", \"import sys\\nfrom itertools import accumulate, chain\\nMOD = 10 ** 9 + 7\\n\\ndef main():\\n\\ts = sys.stdin.readline().strip()\\n\\tdigits = len(s)\\n\\ttotal = 0\\n\\tten_to_i = list(accumulate(range(0, 10 ** 5 + 1), lambda prev, _: prev * 10 % MOD, initial=1))\\n\\tlookup = chain([1], ten_to_i)\\n\\tlookup = map(lambda p: p[0] * p[1] % MOD, enumerate(lookup))\\n\\tlookup = list(accumulate(lookup))\\n\\tfor (i, c) in enumerate(reversed(s)):\\n\\t\\td = int(c)\\n\\t\\ttotal += d * lookup[i]\\n\\t\\ttotal %= MOD\\n\\t\\tleft = digits - (i + 1)\\n\\t\\ttotal += d * ten_to_i[i] * left * (left + 1) // 2\\n\\t\\ttotal %= MOD\\n\\tprint(total)\\nmain()\\n\", \"n = list(input())\\ns = 0\\nn = n[::-1]\\nt = len(n)\\nsum = 0\\ns = 1\\np = 0\\nb = 0\\nfor i in range(t):\\n\\ta = int(n[i])\\n\\tif a != 0:\\n\\t\\tif i == 1:\\n\\t\\t\\tp = 1\\n\\t\\tsum = (sum + a * s * (t - i - 1) * (t - i) // 2 + a * (b + i * p)) % 1000000007\\n\\t\\tb = (b + i * p) % 1000000007\\n\\t\\tp = p * 10 % 1000000007\\n\\t\\ts = s * 10 % 1000000007\\n\\telse:\\n\\t\\tif i == 1:\\n\\t\\t\\tp = 1\\n\\t\\tb = (b + i * p) % 1000000007\\n\\t\\tp = p * 10 % 1000000007\\n\\t\\ts = s * 10 % 1000000007\\nprint(sum)\\n\", \"s = input()\\nMOD = 10 ** 9 + 7\\nj = len(s)\\ndp = []\\nfor i in range(j + 1):\\n\\tdp.append([])\\n\\tfor k in range(3):\\n\\t\\tdp[-1].append(0)\\nfor i in range(j):\\n\\tdp[i + 1][0] = (dp[i][0] * 10 + int(s[i])) % MOD\\n\\tdp[i + 1][1] = (dp[i][0] + dp[i][1]) % MOD\\n\\tdp[i + 1][2] = (dp[i][2] * 10 + i * (i + 1) // 2 * int(s[i]) + 10 * dp[i][1]) % MOD\\nprint((dp[j][2] + dp[j][1]) % MOD)\\n\", \"mod = 10 ** 9 + 7\\nn = str(input())\\nlength = len(n)\\nans = 0\\ndp = [0] * length\\n\\ndef func():\\n\\tfor j in range(0, length):\\n\\t\\tres = pow(10, j, mod) * (j + 1) % mod\\n\\t\\tdp[j] = res\\n\\tfor i in range(1, length):\\n\\t\\tdp[i] = (dp[i - 1] + dp[i]) % mod\\nfunc()\\nfor i in range(length):\\n\\tif n[i] != '0':\\n\\t\\tnop = max(0, i)\\n\\t\\tnos = length - 1 - i\\n\\t\\tans += int(n[i]) * (nop * (nop + 1) // 2) * pow(10, nos, mod) % mod\\n\\t\\tif nos != 0:\\n\\t\\t\\tans += dp[nos - 1] * int(n[i]) % mod\\nprint(ans % mod)\\n\", \"M = 10 ** 9 + 7\\narr = input()\\nn = len(arr)\\ntens = [1] * (n + 1)\\nfor i in range(1, n + 1):\\n\\ttens[i] = tens[i - 1] * 10 % M\\ndp = [0] * n\\nfor i in range(n - 2, -1, -1):\\n\\tdp[i] = (n - i - 1) * tens[n - i - 2] + dp[i + 1]\\nans = 0\\nfor i in range(n):\\n\\tdp[i] += (i * i + i) // 2 * tens[n - i - 1] % M\\n\\tans += int(arr[i]) * dp[i]\\n\\tans %= M\\nprint(ans)\\n\", \"MOD = 10 ** 9 + 7\\ns = input().strip()\\nn = len(s)\\nX = [0] * (n + 1)\\nY = [0] * (n + 1)\\nfor i in range(1, n + 1):\\n\\tX[i] = (X[i - 1] * 10 + int(s[i - 1])) % MOD\\n\\tY[i] = Y[i - 1] + X[i]\\nR = 0\\nt = 1\\ntt = 0\\nfor i in range(n, 0, -1):\\n\\tR = (R + Y[i - 1] * t + tt * i) % MOD\\n\\ttt = (tt + int(s[i - 1]) * t) % MOD\\n\\tt = t * 10 % MOD\\nprint(R)\\n\", \"import sys\\ninput = sys.stdin.readline\\nMOD = 10 ** 9 + 7\\nN = 10 ** 5 + 100\\nfact = [0 for _ in range(N)]\\ninvfact = [0 for _ in range(N)]\\nfact[0] = 1\\nfor i in range(1, N):\\n\\tfact[i] = fact[i - 1] * i % MOD\\ninvfact[N - 1] = pow(fact[N - 1], MOD - 2, MOD)\\nfor i in range(N - 2, -1, -1):\\n\\tinvfact[i] = invfact[i + 1] * (i + 1) % MOD\\n\\ndef nCk(n, k):\\n\\tif k < 0 or n < k:\\n\\t\\treturn 0\\n\\telse:\\n\\t\\treturn fact[n] * invfact[k] * invfact[n - k] % MOD\\n\\ndef main():\\n\\tn = input().strip()\\n\\tans = 0\\n\\tl = len(n)\\n\\tplus = 0\\n\\tplus2 = 1\\n\\tplus3 = 1\\n\\tfor (i, str_num) in enumerate(n[::-1]):\\n\\t\\tnum = int(str_num)\\n\\t\\tj = l - i - 1\\n\\t\\tans += nCk(j + 1, 2) * pow(10, i, MOD) * num\\n\\t\\tans %= MOD\\n\\t\\tans += num * plus\\n\\t\\tans %= MOD\\n\\t\\tplus += plus2 * plus3\\n\\t\\tplus2 *= 10\\n\\t\\tplus3 += 1\\n\\t\\tplus %= MOD\\n\\t\\tplus2 %= MOD\\n\\t\\tplus3 %= MOD\\n\\tprint(ans)\\nmain()\\n\", \"import sys\\nimport math as m\\nMOD = int(1000000000.0 + 7)\\nn = input()\\nl = len(n)\\nf = [0] * 1000001\\nf[0] = 0\\nf[1] = 1\\npos = 10\\nfor i in range(2, l):\\n\\tf[i] = (f[i - 1] + i * pos % MOD) % MOD\\n\\tpos = pos * 10 % MOD\\nans_ = int(0)\\npos_ = 1\\nfor i in range(l - 1, -1, -1):\\n\\tif i == 0:\\n\\t\\ttmp1 = 0\\n\\telse:\\n\\t\\ttmp1 = i * (i + 1) // 2 % MOD * int(n[i]) % MOD % MOD * pos_ % MOD\\n\\ttmp2 = int(n[i]) * f[l - 1 - i] % MOD\\n\\tans_ = ((ans_ + tmp1) % MOD + tmp2) % MOD\\n\\tpos_ = pos_ * 10 % MOD\\nprint(ans_)\\n\", \"from __future__ import division, print_function\\nfrom fractions import Fraction\\nimport sys\\nimport os\\nfrom io import BytesIO, IOBase\\nfrom itertools import *\\nimport bisect\\nfrom heapq import *\\nfrom math import ceil, floor\\nfrom copy import *\\nfrom collections import deque, defaultdict\\nfrom collections import Counter as counter\\nfrom itertools import combinations\\nfrom itertools import permutations as permutate\\nfrom bisect import bisect_left as bl\\nfrom operator import *\\nfrom bisect import bisect_right as br\\nfrom bisect import bisect\\nBUFSIZE = 8192\\nfrom sys import stderr\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n\\ndef print(*args, **kwargs):\\n\\t(sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))\\n\\tat_start = True\\n\\tfor x in args:\\n\\t\\tif not at_start:\\n\\t\\t\\tfile.write(sep)\\n\\t\\tfile.write(str(x))\\n\\t\\tat_start = False\\n\\tfile.write(kwargs.pop('end', '\\\\n'))\\n\\tif kwargs.pop('flush', False):\\n\\t\\tfile.flush()\\nif sys.version_info[0] < 3:\\n\\t(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))\\nelse:\\n\\t(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\nfrom types import GeneratorType\\n\\ndef iterative(f, stack=[]):\\n\\n\\tdef wrapped_func(*args, **kwargs):\\n\\t\\tif stack:\\n\\t\\t\\treturn f(*args, **kwargs)\\n\\t\\tto = f(*args, **kwargs)\\n\\t\\twhile True:\\n\\t\\t\\tif type(to) is GeneratorType:\\n\\t\\t\\t\\tstack.append(to)\\n\\t\\t\\t\\tto = next(to)\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tstack.pop()\\n\\t\\t\\tif not stack:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tto = stack[-1].send(to)\\n\\t\\treturn to\\n\\treturn wrapped_func\\nmod = 1000000007\\n\\ndef inp():\\n\\treturn sys.stdin.readline().rstrip('\\\\r\\\\n')\\n\\ndef out(var):\\n\\tsys.stdout.write(str(var))\\n\\ndef lis():\\n\\treturn list(map(int, inp().split()))\\n\\ndef stringlis():\\n\\treturn list(map(str, inp().split()))\\n\\ndef sep():\\n\\treturn map(int, inp().split())\\n\\ndef strsep():\\n\\treturn map(str, inp().split())\\n\\ndef fsep():\\n\\treturn map(float, inp().split())\\n\\ndef nextline():\\n\\tout('\\\\n')\\n\\ndef testcase(t):\\n\\tfor p in range(t):\\n\\t\\tsolve()\\n\\ndef pow(x, y, p):\\n\\tres = 1\\n\\tx = x % p\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\twhile y > 0:\\n\\t\\tif y & 1 == 1:\\n\\t\\t\\tres = res * x % p\\n\\t\\ty = y >> 1\\n\\t\\tx = x * x % p\\n\\treturn res\\nfrom functools import reduce\\n\\ndef factors(n):\\n\\treturn set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\\n\\ndef gcd(a, b):\\n\\tif a == b:\\n\\t\\treturn a\\n\\twhile b > 0:\\n\\t\\t(a, b) = (b, a % b)\\n\\treturn a\\n\\ndef prefix_sum(ar):\\n\\treturn list(accumulate(ar))\\n\\ndef suffix_sum(ar):\\n\\treturn list(accumulate(ar[::-1]))[::-1]\\nfrom collections import defaultdict\\n\\ndef numberOfSetBits(i):\\n\\ti = i - (i >> 1 & 1431655765)\\n\\ti = (i & 858993459) + (i >> 2 & 858993459)\\n\\treturn ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\\n\\ndef solve():\\n\\ts = inp()\\n\\tn = len(s)\\n\\tar = [0]\\n\\tfor i in s:\\n\\t\\tar.append((ar[-1] * 10 + int(i)) % mod)\\n\\tc = 0\\n\\tneg = 0\\n\\tfor i in range(n, -1, -1):\\n\\t\\tneg += c * ar[i]\\n\\t\\tneg %= mod\\n\\t\\tc = (10 * c + 1) % mod\\n\\tc = 1\\n\\tpos = 0\\n\\tfor i in range(n, -1, -1):\\n\\t\\tpos += c * i * ar[i]\\n\\t\\tpos %= mod\\n\\t\\tc = 10 * c % mod\\n\\tdif = ((pos - neg) % mod + mod) % mod\\n\\tt = n * (n + 1) // 2\\n\\tt %= mod\\n\\tt *= ar[-1]\\n\\tt %= mod\\n\\tprint(((t - dif) % mod + mod) % mod)\\nsolve()\\n\", \"mod = 10 ** 9 + 7\\ns = input()[::-1]\\nn = len(s)\\nsuff = 0\\nprev = 0\\na = [0] * (n + 1)\\ntotal = 0\\nfor i in range(n):\\n\\ttotal = (total + int(s[n - i - 1]) * pow(10, n - i - 1, mod)) % mod\\n\\tprev = (int(s[i]) * pow(10, i, mod) + prev) % mod\\n\\tsuff = (suff + prev) % mod\\n\\ta[i + 1] = (a[i] * 10 + 10) % mod\\ns = s[::-1]\\npref = 0\\nans = 0\\nfor i in range(n):\\n\\tsuff -= total\\n\\tsuff += mod\\n\\tsuff %= mod\\n\\tans += pref * (a[n - i - 1] + 1) + suff\\n\\tans %= mod\\n\\tpref = (pref * 10 + int(s[i])) % mod\\n\\ttotal -= int(s[i]) * pow(10, n - i - 1, mod)\\n\\ttotal += mod\\n\\ttotal %= mod\\nprint(ans)\\n\", \"def inv(x):\\n\\treturn pow(x, 1000000005, 1000000007)\\ns = input()\\nans = 0\\nn = len(s)\\nfor i in range(n - 1, -1, -1):\\n\\tz = pow(10, n - 1 - i, 1000000007) * int(s[i])\\n\\tz = z * (i * (i + 1)) // 2\\n\\tans += z\\n\\tans %= 1000000007\\n\\tk = n - 1 - i\\n\\top = 0\\n\\top += pow(10, k, 1000000007) * (9 * k - 1)\\n\\top %= 1000000007\\n\\top += 1\\n\\top = op * inv(81)\\n\\top %= 1000000007\\n\\top = op * int(s[i])\\n\\tans += op\\n\\tans %= 1000000007\\nprint(ans)\\n\", \"import os\\nimport sys\\nimport io\\nimport functools\\nimport copy\\nimport math\\nGANS = []\\n\\ndef cmp(x, y):\\n\\tif x[1] == y[1]:\\n\\t\\treturn -(y[0] - x[0])\\n\\treturn -(x[1] - y[1])\\nt = input()\\nm = int(1000000000.0 + 7)\\nd = [1]\\nfor i in range(100010):\\n\\td.append(d[-1] * 10 % m)\\n\\ndef prefsum(e, s=1):\\n\\treturn int((e - s + 1) * (e + s) // 2)\\npref = []\\ncur = []\\nans = 0\\nsu = 0\\n\\ndef mi10(po):\\n\\treturn d[po]\\nfor (p, i) in enumerate(t):\\n\\tsu += int(i)\\n\\tsu %= m\\n\\tpref.append(su)\\nfor (p, i) in enumerate(t[::-1]):\\n\\tcur = 0\\n\\tif p:\\n\\t\\tcur += pref[-p - 1] * p % m * mi10(p - 1) % m\\n\\t\\tcur %= m\\n\\tcur += int(i) * int(prefsum(len(t) - p - 1)) % m * mi10(p) % m\\n\\tans = (ans + cur) % m\\nprint(ans)\\n\", \"mod = int(1000000000.0 + 7)\\ns = input()\\nn = len(s)\\npref = [0] * (n + 1)\\nfor i in range(n):\\n\\tpref[i + 1] = (int(s[i]) + pref[i] * 10) % mod\\nfor i in range(n):\\n\\tpref[i + 1] = (pref[i + 1] + pref[i]) % mod\\nres = 0\\nacc = 0\\nfor i in range(n, 0, -1):\\n\\tres += pref[i - 1] * pow(10, n - i, mod) + i * acc\\n\\tres %= mod\\n\\tacc = acc + int(s[i - 1]) * pow(10, n - i, mod) % mod\\nprint(res)\\n\", \"from sys import stdin, stdout\\ninput = stdin.readline\\nprint = lambda x: stdout.write(str(x) + '\\\\n')\\nN = input().strip()\\nl = len(N)\\nmod = 10 ** 9 + 7\\npow10 = [1]\\nfor i in range(1, l + 1):\\n\\tpow10.append(pow10[-1] * 10 % mod)\\ncache = [0]\\nfor i in range(l - 1):\\n\\tcache.append((cache[-1] + (i + 1) * pow10[i]) % mod)\\ncache = cache[::-1]\\nfor (i, ele) in enumerate(N):\\n\\tif 0 < i < l - 1:\\n\\t\\tans += (int(ele) * cache[i] + int(ele) * pow10[l - i - 1] * (1 + i) * i // 2) % mod\\n\\t\\tans %= mod\\n\\telif i == 0:\\n\\t\\tans = int(N[0]) * cache[0] % mod\\n\\telse:\\n\\t\\tans += int(ele) * pow10[l - i - 1] * (1 + i) * i // 2 % mod\\n\\t\\tans %= mod\\nprint(ans)\\n\", \"def modInverse(a, m):\\n\\tm0 = m\\n\\ty = 0\\n\\tx = 1\\n\\tif m == 1:\\n\\t\\treturn 0\\n\\twhile a > 1:\\n\\t\\tq = a // m\\n\\t\\tt = m\\n\\t\\tm = a % m\\n\\t\\ta = t\\n\\t\\tt = y\\n\\t\\ty = x - q * y\\n\\t\\tx = t\\n\\tif x < 0:\\n\\t\\tx = x + m0\\n\\treturn x\\n\\ndef power(x, y, p):\\n\\tres = 1\\n\\tx = x % p\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\twhile y > 0:\\n\\t\\tif y & 1 == 1:\\n\\t\\t\\tres = res * x % p\\n\\t\\ty = y >> 1\\n\\t\\tx = x * x % p\\n\\treturn res\\ns = input()\\np = 10 ** 9 + 7\\nreq = 111111112\\nn = len(s)\\nj = n - 1\\nans = 0\\ncurr = 0\\ns1 = 0\\nwhile j >= 0:\\n\\ts1 = (curr + int(s[j]) * power(10, n - 1 - j, p)) % p\\n\\tcurr = s1\\n\\tres = curr * j\\n\\tans = (ans + res) % p\\n\\tj += -1\\ns1 = 0\\ncurr = 0\\nj = 0\\nwhile j < n:\\n\\ts1 = (curr * 10 + int(s[j])) % p\\n\\tcurr = s1\\n\\tres = curr * ((power(10, n - 1 - j, p) - 1) * req) % p\\n\\tans = (ans + res) % p\\n\\tj += 1\\nprint(ans % p)\\n\", \"p = 10 ** 9 + 7\\n\\ndef process(A):\\n\\tcurr1 = [0, 0]\\n\\tcurr2 = [0, 0]\\n\\tcurr3 = [0, 1]\\n\\tfor x in A:\\n\\t\\t(a, b) = curr1\\n\\t\\t(c, d) = curr2\\n\\t\\t(e, f) = curr3\\n\\t\\t(curr1, curr2) = ([a + e, b + f], [10 * a + 10 * c + int(x) * (b + d), b + d])\\n\\t\\tcurr1[0] = curr1[0] % p\\n\\t\\tcurr2[0] = curr2[0] % p\\n\\t\\tcurr3 = [10 * e + int(x), 1]\\n\\t\\tcurr3[0] = curr3[0] % p\\n\\treturn (curr1[0] + curr2[0]) % p\\nn = input()\\nprint(process(n))\\n\", \"mod = 10 ** 9 + 7\\ns = [int(d) for d in input()]\\ndp = [0 for j in range(10 ** 5 + 10)]\\nss = [0 for j in range(10 ** 5 + 10)]\\nss[0] = s[0]\\ncurr = s[0]\\nfor i in range(1, len(s)):\\n\\tdigit = s[i]\\n\\tdp[i] = (dp[i - 1] * 10 + int(s[i] * i * (i + 1) / 2) + ss[i - 1]) % mod\\n\\tcurr = (curr * 10 + s[i]) % mod\\n\\tss[i] = (ss[i - 1] + curr) % mod\\nprint(dp[len(s) - 1])\\n\", \"import itertools\\nimport math\\nimport sys\\nfrom collections import defaultdict\\n\\ndef stdinWrapper():\\n\\tdata = '107\\\\n\\\\n'\\n\\tfor line in data.split('\\\\n'):\\n\\t\\tyield line\\nif '--debug' not in sys.argv:\\n\\n\\tdef stdinWrapper():\\n\\t\\twhile True:\\n\\t\\t\\tyield sys.stdin.readline()\\ninputs = stdinWrapper()\\n\\ndef inputWrapper():\\n\\treturn next(inputs)\\n\\ndef getType(_type):\\n\\treturn _type(inputWrapper())\\n\\ndef getArray(_type):\\n\\treturn [_type(x) for x in inputWrapper().split()]\\n\\ndef tuplerize(method):\\n\\n\\tdef wrap(*args, **kwargs):\\n\\t\\tres = method(*args, **kwargs)\\n\\t\\tif not isinstance(res, (tuple, list)):\\n\\t\\t\\tres = (res,)\\n\\t\\treturn res\\n\\treturn wrap\\n\\n@tuplerize\\ndef solve(n):\\n\\tmod = 10 ** 9 + 7\\n\\tdp = [[0, (0, 0), (0, 0)] for _ in range(len(n))]\\n\\tdp[0][0] = int(n[0])\\n\\tdp[0][1] = (1, 0)\\n\\tfor i in range(1, len(n)):\\n\\t\\td = int(n[i])\\n\\t\\tdp[i][0] = (dp[i - 1][0] * 10 % mod + d) % mod\\n\\t\\tdp[i][1] = (1 + dp[i - 1][1][0], (dp[i - 1][0] + dp[i - 1][1][1]) % mod)\\n\\t\\tdp[i][2] = (dp[i - 1][1][0] + dp[i - 1][2][0], ((dp[i - 1][1][1] * 10 % mod + dp[i - 1][1][0] * d % mod) % mod + (dp[i - 1][2][1] * 10 % mod + dp[i - 1][2][0] * d % mod) % mod) % mod)\\n\\treturn (dp[-1][2][1] + dp[-1][1][1]) % mod\\nn = input()\\nres = solve(n)\\nprint(*res)\\n\", \"m = 1000000007\\nans = 0\\nstr = input()\\nn = len(str)\\ndp = [0] * (n + 1)\\nten = [1] * (n + 1)\\nfor i in range(1, n + 1):\\n\\tten[i] = ten[i - 1] * 10 % m\\n\\tdp[i] = (dp[i - 1] + i * ten[i - 1]) % m\\nfor i in range(n):\\n\\tans = ans + (dp[n - i - 1] + (i * i + i) // 2 * ten[n - i - 1]) * int(str[i])\\n\\tans = ans % m\\nprint(ans)\\n\", \"mod = 10 ** 9 + 7\\nn = input()\\nL = len(n)\\nsm = 0\\npre = 0\\ntemp = 0\\ni = 0\\nwhile i < L:\\n\\tx = int(n[i])\\n\\tsm = sm * 10 % mod\\n\\tif temp & 1:\\n\\t\\tfreq = temp + 1 >> 1\\n\\t\\tfreq = freq * temp % mod\\n\\telse:\\n\\t\\tfreq = temp >> 1\\n\\t\\tfreq = freq * (temp + 1) % mod\\n\\tsm = (sm + freq * x % mod) % mod\\n\\tsm = (sm + pre * (L - temp) % mod) % mod\\n\\tpre = (pre + x) % mod\\n\\ttemp += 1\\n\\ti += 1\\nprint(sm)\\n\", \"MODN = int(1000000000.0 + 7)\\ns = input()\\nn = len(s)\\nprefix = []\\nsum = 0\\nfor i in s:\\n\\tsum += ord(i) - ord('0')\\n\\tsum %= MODN\\n\\tprefix.append(sum)\\nans = 0\\nfor i in range(n - 1):\\n\\tans += pow(10, i, MODN) * (i + 1) * prefix[n - 1 - i - 1]\\n\\tans %= MODN\\nfor i in range(1, n + 1):\\n\\tlf = i - 1\\n\\ta = ord(s[i - 1]) - ord('0')\\n\\tans += (1 + lf) * lf // 2 % MODN * a * pow(10, n - i, MODN)\\n\\tans %= MODN\\nprint(ans)\\n\", \"mod = 10 ** 9 + 7\\nbb = 1\\nwhile bb:\\n\\ts = input()\\n\\tn = len(s)\\n\\tn = len(s)\\n\\tc = 0\\n\\tans = 0\\n\\td = 0\\n\\te = 1\\n\\tfor i in range(n - 1, 0, -1):\\n\\t\\tc = (int(s[i]) * e + c) % mod\\n\\t\\td = (d + c) % mod\\n\\t\\te = e * 10 % mod\\n\\t\\tans = (ans + d) % mod\\n\\tc = 0\\n\\tm = 0\\n\\te = 1\\n\\twhile c <= n - 2:\\n\\t\\tm = (m + e) % mod\\n\\t\\te = e * 10 % mod\\n\\t\\tc += 1\\n\\tc = 0\\n\\tk = n - 2\\n\\tfor i in range(n - 1):\\n\\t\\tc = (c * 10 + int(s[i])) % mod\\n\\t\\tans = (ans + c * m) % mod\\n\\t\\tm = (m - pow(10, k, mod)) % mod\\n\\t\\tk -= 1\\n\\tprint(ans)\\n\\tbb -= 1\\n\", \"from sys import stdin\\ninput = stdin.readline\\nmod = 10 ** 9 + 7\\ns = input()\\nn = len(s) - 1\\ninv = pow(2, mod - 2, mod)\\ninv9 = pow(9, mod - 2, mod)\\ndp = [0] * n\\nans = n * (n - 1) * inv * int(s[n - 1]) % mod\\nfor i in range(n - 2, -1, -1):\\n\\tdp[i] = (dp[i + 1] * 10 + (pow(10, n - i - 1, mod) - 1) * inv9) % mod\\n\\tans = (ans + int(s[i]) * (pow(10, n - i - 1, mod) * i * (i + 1) * inv + dp[i])) % mod\\nprint(ans)\\n\", \"s = input()\\nans = 0\\nmod = 10 ** 9 + 7\\nn = len(s)\\nps = [0]\\ncp = 1\\nfor i in range(n - 1, -1, -1):\\n\\tps.append((ps[-1] + int(s[i]) * cp) % mod)\\n\\tcp = cp * 10 % mod\\nps.reverse()\\nprefs = 0\\nlastpref = 0\\nfor i in range(n):\\n\\tnextdigs = ps[i + 1]\\n\\tans = (ans + prefs * pow(10, n - i - 1, mod) % mod + nextdigs * (i + 1)) % mod\\n\\tlastpref = (lastpref * 10 + int(s[i])) % mod\\n\\tprefs = (prefs + lastpref) % mod\\nprint(ans)\\n\", \"import sys\\nimport math, bisect\\nsys.setrecursionlimit(10 ** 5)\\nfrom itertools import groupby, accumulate\\nfrom heapq import heapify, heappop, heappush\\nfrom collections import deque, Counter, defaultdict\\n\\ndef I():\\n\\treturn int(sys.stdin.readline())\\n\\ndef neo():\\n\\treturn map(int, sys.stdin.readline().split())\\n\\ndef Neo():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\nnum = input()\\nn = len(num)\\nans = 0\\nmod = 1000000007\\ntis = [0] * n\\nsim = int(num[0])\\nans = 0\\nfor i in range(1, n):\\n\\ttis[i] = (n - i) * sim + i * (i + 1) // 2 * int(num[i])\\n\\tsim = sim + int(num[i])\\nten = [1]\\nfor _ in range(n):\\n\\tten.append(ten[-1] * 10 % mod)\\nfor i in range(n):\\n\\tans = (ans + tis[n - 1 - i] * ten[i]) % mod\\nprint(ans)\\n\", \"s = input()\\nln = len(s)\\nres = 0\\nMOD = 10 ** 9 + 7\\nleft_del = [0] * ln\\nright_del = [0] * ln\\nlmul = rmul = 1\\nfor i in range(ln - 1, -1, -1):\\n\\tif i < ln - 1:\\n\\t\\tright_del[i] = rmul * (ln - 1 - i) % MOD + right_del[i + 1]\\n\\t\\trmul = rmul * 10 % MOD\\n\\t\\tright_del[i] = right_del[i] % MOD\\n\\tleft_del[i] = lmul\\n\\tlmul = lmul * 10 % MOD\\nfor i in range(ln):\\n\\tv = int(s[i])\\n\\tres += v % MOD * (i * (i + 1) // 2) % MOD * left_del[i] % MOD\\n\\tres += v * right_del[i] % MOD\\n\\tres = res % MOD\\nprint(res)\\n\", \"import sys\\n\\ndef redirect():\\n\\tsys.stdin = open('input.txt', 'r')\\n\\tsys.stdout = open('output.txt', 'w')\\ninp = input()[::-1]\\nmod = 10 ** 9 + 7\\nn = len(inp)\\nb_1 = 0\\ndp_1 = 0\\nb = b_1\\ndp = dp_1\\ntenth = 1\\nfor i in range(0, n):\\n\\tx = (n - i - 1) * (n - i) // 2 * int(inp[i]) * tenth\\n\\ty = b_1 * int(inp[i])\\n\\tdp = dp_1 + x + y\\n\\tb = b_1 + (i + 1) * tenth\\n\\tdp %= mod\\n\\tb %= mod\\n\\tb_1 = b\\n\\tdp_1 = dp\\n\\ttenth = tenth * 10 % mod\\nprint(dp)\\n\", \"import os, sys\\nfrom io import BytesIO, IOBase\\n\\ndef main():\\n\\tmod = 10 ** 9 + 7\\n\\tpower = [1]\\n\\tfor _ in range(10 ** 5 + 1):\\n\\t\\tpower.append(power[-1] * 10 % mod)\\n\\tn = input().strip()\\n\\tans = 0\\n\\ty = 0\\n\\tx = len(n) - 1\\n\\tqq = pow(9, mod - 2, mod)\\n\\tqq1 = pow(81, mod - 2, mod)\\n\\tfor i in range(len(n) - 1):\\n\\t\\trr = (x * power[x] - 1) * qq % mod\\n\\t\\trr1 = 10 * (power[x - 1] - 1) * qq1 % mod\\n\\t\\trr2 = y * (y + 1) // 2 * power[x] % mod\\n\\t\\tans += (rr - rr1 + rr2) * int(n[i]) % mod\\n\\t\\tans %= mod\\n\\t\\tx -= 1\\n\\t\\ty += 1\\n\\tans += y * (y + 1) // 2 * int(n[-1]) % mod\\n\\tprint(ans % mod)\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nmain()\\n\", \"mod = 1000000007\\ns = input()\\nn = len(s)\\n(su, ans, c, x) = (0, [], 0, 0)\\nfor i in s:\\n\\tsu += int(i)\\nfor i in range(1, n):\\n\\tsu -= int(s[-i])\\n\\tss = su * i + int(s[-i]) * ((n - i) * (n - i + 1)) // 2 + c\\n\\tif i == n - 1:\\n\\t\\tx = ss\\n\\telse:\\n\\t\\tans.append(ss % 10)\\n\\tc = ss // 10\\nans.reverse()\\npp = str(x) + ''.join(map(str, ans))\\nprint(int(pp) % mod)\\n\", \"a = list(map(int, list(input())))\\nn = len(a)\\nc = 0\\nd = 10 ** 9 + 7\\nfor i in range(n - 1):\\n\\tk = n - i - 1\\n\\tp = a[i] * (k * pow(10, k + 1, d) - (k + 1) * pow(10, k, d) + 1)\\n\\tp = p * pow(81, d - 2, d)\\n\\tc += p % d\\ne = 0\\nfor i in range(n - 1, 0, -1):\\n\\te += a[i] * pow(10, n - i - 1, d)\\n\\tc += i * e % d\\nprint(c % d)\\n\", \"MODULUS = 10 ** 9 + 7\\n\\ndef solve(n):\\n\\tl = len(n)\\n\\tif l < 2:\\n\\t\\treturn 0\\n\\tresult = int(n[0]) + int(n[1])\\n\\tif l == 2:\\n\\t\\treturn result\\n\\tx = 0\\n\\ty = int(n[0])\\n\\tz = int(n[0])\\n\\tfor i in range(2, l):\\n\\t\\tx += i\\n\\t\\tresult = (result * 10 % MODULUS + int(n[i]) * x % MODULUS) % MODULUS\\n\\t\\tresult = (result + int(n[i]) % MODULUS) % MODULUS\\n\\t\\ty = (y * 10 % MODULUS + int(n[i - 1]) % MODULUS) % MODULUS\\n\\t\\tz = (z + y % MODULUS) % MODULUS\\n\\t\\tresult = (result + z) % MODULUS\\n\\treturn result\\nn = input()\\nprint(solve(n))\\n\", \"n = input().strip()\\nM = 1000000007\\nl = len(n)\\na = 0\\nb = 0\\nfor (i, c) in enumerate(n[::-1]):\\n\\tc = int(c)\\n\\tp = l - 1 - i\\n\\ta += p * (p + 1) // 2 * c * pow(10, i, M)\\n\\ta += b * c\\n\\ta %= M\\n\\tb += (i + 1) * pow(10, i, M)\\n\\tb %= M\\nprint(a)\\n\", \"import sys\\nimport math\\nfrom collections import defaultdict, Counter\\nmod = pow(10, 9) + 7\\nn = list(map(int, list(input())))\\nn1 = len(n)\\nans = 0\\npre = 0\\nfor i in range(n1 - 1, -1, -1):\\n\\tc = i * (i + 1) // 2\\n\\tp = pow(10, n1 - i - 1, mod)\\n\\tc1 = n[i] * pre % mod\\n\\tcur = c * p * n[i] % mod\\n\\tcur1 = pre * n[i] % mod\\n\\tans = (ans + cur + cur1) % mod\\n\\tpre = ((n1 - i) * p + pre) % mod\\nprint(ans)\\n\", \"from sys import stdin\\ninput = stdin.readline\\n\\ndef A():\\n\\tt = int(input())\\n\\tfor _ in range(t):\\n\\t\\tl = list(map(int, input().split()))\\n\\t\\tl.sort()\\n\\t\\tx = l[2] - l[1] - l[0]\\n\\t\\tx = max(x, 0) + 1\\n\\t\\tprint(x)\\n\\ndef B():\\n\\tt = int(input())\\n\\tfor _ in range(t):\\n\\t\\t(n, m) = map(int, input().split())\\n\\t\\tmat = [[] for i in range(n)]\\n\\t\\tnewMat = [[0 for j in range(m)] for i in range(n)]\\n\\t\\tfor i in range(n):\\n\\t\\t\\ta = list(map(int, input().split()))\\n\\t\\t\\tmat[i] = a\\n\\t\\ttot = 0\\n\\t\\tfor i in range(n // 2):\\n\\t\\t\\tfor j in range(m // 2):\\n\\t\\t\\t\\ts = sorted([mat[i][j], mat[i][m - j - 1], mat[n - i - 1][j], mat[n - i - 1][m - j - 1]])\\n\\t\\t\\t\\tdest = round(newMat[i][j] / 4)\\n\\t\\t\\t\\tdest = max(dest, s[1])\\n\\t\\t\\t\\tdest = min(dest, s[2])\\n\\t\\t\\t\\tfor k in s:\\n\\t\\t\\t\\t\\ttot += abs(k - dest)\\n\\t\\tif n % 2 == 1:\\n\\t\\t\\tfor j in range(m // 2):\\n\\t\\t\\t\\tdest = (mat[n // 2][j] + mat[n // 2][m - j - 1]) // 2\\n\\t\\t\\t\\ttot += abs(mat[n // 2][j] - dest)\\n\\t\\t\\t\\ttot += abs(mat[n // 2][m - j - 1] - dest)\\n\\t\\tif m % 2 == 1:\\n\\t\\t\\tfor i in range(n // 2):\\n\\t\\t\\t\\tdest = (mat[i][m // 2] + mat[n - i - 1][m // 2]) // 2\\n\\t\\t\\t\\ttot += abs(mat[i][m // 2] - dest)\\n\\t\\t\\t\\ttot += abs(mat[n - i - 1][m // 2] - dest)\\n\\t\\tprint(tot)\\n\\ndef C():\\n\\ta = list(map(int, input().rstrip()))\\n\\tn = len(a)\\n\\tmod = 10 ** 9 + 7\\n\\tdp = [0] * n\\n\\tdp[0] = 0\\n\\tfor i in range(1, n):\\n\\t\\tdp[i] = (dp[i - 1] + i * pow(10, i - 1, mod)) % mod\\n\\ttot = 0\\n\\tfor i in range(0, n):\\n\\t\\tif i == n - 1:\\n\\t\\t\\tleft = 0\\n\\t\\telse:\\n\\t\\t\\tleft = (n - i - 1) * (n - i) // 2 % mod\\n\\t\\t\\tleft = left * a[n - i - 1] * pow(10, i, mod) % mod\\n\\t\\tright = a[n - i - 1] * dp[i] % mod\\n\\t\\ttot = (tot + left + right) % mod\\n\\tprint(tot)\\nC()\\n\", \"MOD = 10 ** 9 + 7\\nsn = list(map(int, list(input())))\\nN = len(sn)\\ntm = [1]\\nam = [0]\\ns = 1\\npsn = [0]\\nfor i in range(N - 1):\\n\\ttm.append(tm[-1] * 10 % MOD)\\n\\tpsn.append(psn[-1] + sn[i])\\n\\tam.append((am[-1] + s) % MOD)\\n\\ts += 1\\nres = 0\\nfor i in range(1, N):\\n\\tres += sn[i] * am[i] * tm[N - i - 1]\\n\\tres += tm[i - 1] * i * psn[-i]\\nres %= MOD\\nprint(res)\\n\", \"from __future__ import division, print_function\\nfrom fractions import Fraction\\nimport sys\\nimport os\\nfrom io import BytesIO, IOBase\\nfrom heapq import *\\nfrom math import gcd, factorial, floor, ceil\\nfrom copy import deepcopy\\nfrom collections import deque\\nfrom bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nfrom bisect import bisect\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n\\ndef print(*args, **kwargs):\\n\\t(sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))\\n\\tat_start = True\\n\\tfor x in args:\\n\\t\\tif not at_start:\\n\\t\\t\\tfile.write(sep)\\n\\t\\tfile.write(str(x))\\n\\t\\tat_start = False\\n\\tfile.write(kwargs.pop('end', '\\\\n'))\\n\\tif kwargs.pop('flush', False):\\n\\t\\tfile.flush()\\nif sys.version_info[0] < 3:\\n\\t(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))\\nelse:\\n\\t(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\nfrom types import GeneratorType\\n\\ndef iterative(f, stack=[]):\\n\\n\\tdef wrapped_func(*args, **kwargs):\\n\\t\\tif stack:\\n\\t\\t\\treturn f(*args, **kwargs)\\n\\t\\tto = f(*args, **kwargs)\\n\\t\\twhile True:\\n\\t\\t\\tif type(to) is GeneratorType:\\n\\t\\t\\t\\tstack.append(to)\\n\\t\\t\\t\\tto = next(to)\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tstack.pop()\\n\\t\\t\\tif not stack:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tto = stack[-1].send(to)\\n\\t\\treturn to\\n\\treturn wrapped_func\\nmod = 10 ** 9 + 7\\n\\ndef inp():\\n\\treturn sys.stdin.readline().rstrip('\\\\r\\\\n')\\n\\ndef out(var):\\n\\tsys.stdout.write(str(var))\\n\\ndef lis():\\n\\treturn list(map(int, inp().split()))\\n\\ndef stringlis():\\n\\treturn list(map(str, inp().split()))\\n\\ndef sep():\\n\\treturn map(int, inp().split())\\n\\ndef strsep():\\n\\treturn map(str, inp().split())\\n\\ndef zerolist(n):\\n\\treturn [0] * n\\n\\ndef nextline():\\n\\tout('\\\\n')\\n\\ndef testcase(t):\\n\\tfor pp in range(t):\\n\\t\\tsolve(pp)\\n\\ndef printlist(a):\\n\\tfor p in range(0, len(a)):\\n\\t\\tout(str(a[p]) + ' ')\\n\\ndef google(p):\\n\\tprint('Case #' + str(p) + ': ', end='')\\n\\ndef lcm(a, b):\\n\\treturn a * b // gcd(a, b)\\n\\ndef power(x, y, p):\\n\\tres = 1\\n\\tx = x % p\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\twhile y > 0:\\n\\t\\tif y & 1 == 1:\\n\\t\\t\\tres = res * x % p\\n\\t\\ty = y >> 1\\n\\t\\tx = x * x % p\\n\\treturn res\\n\\ndef ncr(n, r):\\n\\treturn factorial(n) // (factorial(r) * factorial(max(n - r, 1)))\\n\\ndef isPrime(n):\\n\\tif n <= 1:\\n\\t\\treturn False\\n\\tif n <= 3:\\n\\t\\treturn True\\n\\tif n % 2 == 0 or n % 3 == 0:\\n\\t\\treturn False\\n\\ti = 5\\n\\twhile i * i <= n:\\n\\t\\tif n % i == 0 or n % (i + 2) == 0:\\n\\t\\t\\treturn False\\n\\t\\ti = i + 6\\n\\treturn True\\n\\ndef solve(case):\\n\\ts = list(inp())\\n\\tn = len(s)\\n\\tfor i in range(n):\\n\\t\\ts[i] = int(s[i])\\n\\tans = [0] * n\\n\\tfor i in range(n):\\n\\t\\tans[i] += i * (i + 1) // 2 * power(10, n - i - 1, mod) % mod\\n\\tnew = [0] * n\\n\\tfor i in range(n - 1):\\n\\t\\tnew[i] = (i + 1) * power(10, i, mod)\\n\\t\\tnew[i] %= mod\\n\\tpre = [0] * (n + 1)\\n\\tfor i in range(n):\\n\\t\\tpre[i] = pre[i - 1] + s[i]\\n\\tfor i in range(n - 1):\\n\\t\\tnew[i] *= pre[n - i - 2]\\n\\t\\tnew[i] %= mod\\n\\tfor i in range(n):\\n\\t\\tans[i] *= s[i]\\n\\t\\tans[i] %= mod\\n\\tfor i in range(n):\\n\\t\\tans[i] += new[i]\\n\\t\\tans[i] %= mod\\n\\tprint(sum(ans) % mod)\\ntestcase(1)\\n\", \"from os import path\\nimport sys\\nfrom heapq import heappush, heappop\\nfrom functools import cmp_to_key as ctk\\nfrom collections import deque, defaultdict as dd\\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\\nfrom itertools import permutations\\nfrom datetime import datetime\\nfrom math import ceil, sqrt, log, gcd\\n\\ndef ii():\\n\\treturn int(input())\\n\\ndef si():\\n\\treturn input().rstrip()\\n\\ndef mi():\\n\\treturn map(int, input().split())\\n\\ndef li():\\n\\treturn list(mi())\\nabc = 'abcdefghijklmnopqrstuvwxyz'\\nmod = 1000000007\\ninf = float('inf')\\nvow = ['a', 'e', 'i', 'o', 'u']\\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\\n\\ndef bo(i):\\n\\treturn ord(i) - ord('a')\\nfile = 1\\n\\ndef solve():\\n\\tm = si()\\n\\tn = len(m)\\n\\tpresum = [0] * n\\n\\tpower = [1] * (n + 1)\\n\\tfor i in range(n):\\n\\t\\tpresum[i] = (i + 1) * power[i]\\n\\t\\tpresum[i] %= mod\\n\\t\\tif i > 0:\\n\\t\\t\\tpresum[i] += presum[i - 1]\\n\\t\\t\\tpresum[i] %= mod\\n\\t\\tpower[i + 1] = power[i]\\n\\t\\tpower[i + 1] *= 10\\n\\t\\tpower[i + 1] %= mod\\n\\tans = 0\\n\\tfor i in range(n):\\n\\t\\tl = i * (i + 1) // 2\\n\\t\\tl *= power[n - i - 1]\\n\\t\\tl %= mod\\n\\t\\tif i < n - 1:\\n\\t\\t\\tr = presum[n - i - 2]\\n\\t\\t\\tl += r\\n\\t\\t\\tl %= mod\\n\\t\\tl *= int(m[i])\\n\\t\\tl %= mod\\n\\t\\tans += l\\n\\t\\tans %= mod\\n\\tprint(ans)\\nif file:\\n\\tif path.exists('input.txt'):\\n\\t\\tsys.stdin = open('input.txt', 'r')\\n\\t\\tsys.stdout = open('output1.txt', 'w')\\n\\telse:\\n\\t\\tinput = sys.stdin.readline\\nsolve()\\n\", \"n = input()\\nmod = 10 ** 9 + 7\\nans = 0\\nsumm = 0\\nnum = int(n[-1])\\na = num\\nj = 0\\npaw = [1]\\nfor i in range(len(n) + 1):\\n\\tpaw.append(paw[-1] * 10 % mod)\\nfor i in range(len(n) - 2, -1, -1):\\n\\tsumm = (summ + (j + 1) * paw[j] % mod) % mod\\n\\tans = ((a + ans) % mod + int(n[i]) * summ % mod) % mod\\n\\tj += 1\\n\\tnum += paw[j] * int(n[i]) % mod\\n\\ta += num\\nprint(ans)\\n\", \"string = input().strip(' ')[::-1]\\nanswer = 0\\nMOD = int(1000000000.0 + 7)\\nright_combs = 0\\nl = len(string)\\nfor i in range(l):\\n\\tdigit = int(string[i])\\n\\tnum_left_elements = l - i - 1\\n\\tanswer += num_left_elements * (num_left_elements + 1) // 2 * digit * pow(10, i, MOD)\\n\\tanswer += right_combs * digit\\n\\tanswer %= MOD\\n\\tright_combs += (i + 1) * pow(10, i, MOD)\\n\\tright_combs %= MOD\\nelse:\\n\\tprint(answer)\\n\", \"from sys import stdin\\ninput = stdin.readline\\nMOD = 10 ** 9 + 7\\n\\ndef solve():\\n\\tn = input().strip()\\n\\tres = 0\\n\\tlength = len(n)\\n\\tm10 = [1] * length\\n\\tfor i in range(1, length):\\n\\t\\tm10[i] = m10[i - 1] * 10 % MOD\\n\\tinv2 = pow(2, MOD - 2, MOD)\\n\\tinv81 = pow(81, MOD - 2, MOD)\\n\\tfor (i, v) in enumerate(n):\\n\\t\\tif v == '0':\\n\\t\\t\\tcontinue\\n\\t\\tv = int(v)\\n\\t\\tl = i\\n\\t\\tr = length - i - 1\\n\\t\\tbase = v * m10[r] % MOD\\n\\t\\tres += base * l * (l + 1) * inv2 % MOD\\n\\t\\tbase2 = v * ((9 * r - 1) * m10[r] + 1) * inv81 % MOD\\n\\t\\tres += base2\\n\\t\\tres %= MOD\\n\\tprint(res)\\nsolve()\\n\", \"import sys\\ninput = sys.stdin.readline\\nfrom collections import defaultdict as dd\\nn = list(map(int, input().strip()))\\npre = []\\nmod = 10 ** 9 + 7\\nnn = len(n)\\npre = [n[0]]\\npo = 1\\ntpo = [1]\\nfor i in range(1, 100000 + 5):\\n\\ttpo.append(tpo[-1] * 10 % mod)\\nfor i in range(1, 100000 + 5):\\n\\ttpo[i] = (tpo[i] + tpo[i - 1]) % mod\\nfor i in range(1, nn):\\n\\tpre.append((10 * pre[i - 1] + n[i]) % mod)\\npre = [0] + pre\\npos = [0] * nn\\npos[-1] = n[-1]\\npo = 1\\nfor i in range(nn - 2, -1, -1):\\n\\tpo = po * 10 % mod\\n\\tpos[i] = (po * n[i] + pos[i + 1]) % mod\\npos = pos + [0]\\nfor i in range(nn - 1, -1, -1):\\n\\tpos[i] = pos[i] + pos[i + 1]\\nans = 0\\nfor i in range(1, nn):\\n\\tpo = tpo[nn - i - 1]\\n\\tsu = pos[i]\\n\\tans = (ans + pre[i] * po + su) % mod\\nprint(ans)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\ndef gcd(a, b):\\n\\tif a == 0:\\n\\t\\treturn b\\n\\treturn gcd(b % a, a)\\n\\ndef lcm(a, b):\\n\\treturn a * b / gcd(a, b)\\nmod = 10 ** 9 + 7\\n\\ndef main():\\n\\ts = input()\\n\\ta = []\\n\\tn = len(s) - 1\\n\\tk = 0\\n\\tfor i in range(n - 1, -1, -1):\\n\\t\\ta.append(s[i])\\n\\t\\tk += int(s[i])\\n\\tpow10 = []\\n\\tc = 1\\n\\tfor i in range(n + 1):\\n\\t\\tpow10.append(c)\\n\\t\\tc *= 10\\n\\t\\tc %= mod\\n\\tans = 0\\n\\tind = 0\\n\\tfor i in range(n):\\n\\t\\tans += pow10[i] * ((n - i - 1) * (n - i) // 2) % mod * int(a[i]) % mod\\n\\t\\tans %= mod\\n\\t\\tans += pow10[i - 1] * i % mod * k % mod\\n\\t\\tans %= mod\\n\\t\\tk -= int(a[ind])\\n\\t\\tind += 1\\n\\tprint(ans)\\n\\treturn\\nmain()\\n\", \"MOD = 10 ** 9 + 7\\ns = input()\\n(cnt1, cnt2, cnt3) = (1, 0, 0)\\n(ans1, ans2, ans3) = (0, 0, 0)\\nans = 0\\nfor i in s:\\n\\ti = int(i)\\n\\t(ans1, ans2, ans3) = ((ans1 * 10 + i) % MOD, (ans2 + ans1) % MOD, ((ans3 + ans2) * 10 % MOD + i * (cnt2 + cnt3) % MOD) % MOD)\\n\\t(cnt2, cnt3) = ((cnt2 + 1) % MOD, (cnt3 + cnt2) % MOD)\\nprint((ans2 + ans3) % MOD)\\n\", \"import sys\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nm = 10 ** 9 + 7\\n\\ndef modExp(a, n, m=10 ** 9 + 7):\\n\\tif n == 0:\\n\\t\\treturn 1\\n\\telif n == 1:\\n\\t\\treturn a\\n\\telse:\\n\\t\\twhile n >= 2:\\n\\t\\t\\tif n % 2 == 0:\\n\\t\\t\\t\\tn = n // 2\\n\\t\\t\\t\\treturn modExp(a % m * (a % m) % m, n, m)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tn = (n - 1) // 2\\n\\t\\t\\t\\treturn a % m * modExp(a % m * (a % m) % m, n, m) % m % m\\ns = input()\\nn = len(s)\\nout = 0\\nc = 0\\nfor i in range(n - 1, -1, -1):\\n\\tx = modExp(10, n - 1 - i) * int(s[i])\\n\\tout += x * (i * (i + 1) // 2 % m)\\n\\tif i < n - 1:\\n\\t\\tc += (n - 1 - i) * modExp(10, n - i - 2)\\n\\t\\tc %= m\\n\\tout += c * int(s[i])\\n\\tout %= m\\nprint(out)\\n\", \"from sys import stdin, stdout\\ns = input()\\nn = len(s)\\nans = 0\\nM = 10 ** 9 + 7\\np10 = [1]\\nfor i in range(n + 2):\\n\\tp10 += [p10[-1] * 10 % M]\\n\\ndef gp_sm(terms):\\n\\tnum = p10[terms] - 1\\n\\tsm = num * pow(9, M - 2, M) % M\\n\\treturn sm\\nfor _ in range(1):\\n\\tpv = [0] * n\\n\\tpv_fb = [0] * n\\n\\tpos = 0\\n\\tfor i in range(n - 1, -1, -1):\\n\\t\\tpv[i] = p10[pos] * int(s[i]) % M\\n\\t\\tif i != n - 1:\\n\\t\\t\\tpv[i] = (pv[i] + pv[i + 1]) % M\\n\\t\\tpos += 1\\n\\tfor i in range(n):\\n\\t\\tif i == 0:\\n\\t\\t\\tpv_fb[i] = int(s[i])\\n\\t\\telse:\\n\\t\\t\\tpv_fb[i] = (pv_fb[i - 1] * 10 + int(s[i])) % M\\n\\tfor i in range(n - 2, -1, -1):\\n\\t\\tpv[i] = (pv[i] + pv[i + 1]) % M\\n\\tfor i in range(n):\\n\\t\\tright_sm = left_sm = 0\\n\\t\\tif i + 1 < n:\\n\\t\\t\\tright_sm = pv[i + 1]\\n\\t\\tzeros = n - i - 1\\n\\t\\tif i - 1 >= 0:\\n\\t\\t\\tleft_sm = pv_fb[i - 1]\\n\\t\\tnew = left_sm * gp_sm(zeros + 1) % M\\n\\t\\tans = (ans + new + right_sm) % M\\n\\tprint(ans)\\n\", \"import sys\\nimport math\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom math import gcd, floor, sqrt, log2, ceil, pi, sin, cos, acos, atan\\nfrom collections import defaultdict as dd\\nfrom bisect import bisect_left as bl, bisect_right as br\\nfrom bisect import insort\\nfrom collections import Counter\\nfrom collections import deque\\nfrom heapq import heappush, heappop, heapify\\nfrom itertools import permutations, combinations\\nmod = int(1000000000.0) + 7\\nip = lambda : int(stdin.readline())\\ninp = lambda : map(int, stdin.readline().split())\\nips = lambda : stdin.readline().rstrip()\\nout = lambda x: stdout.write(str(x) + '\\\\n')\\nt = 1\\nfor _ in range(t):\\n\\ts = ips()\\n\\tn = len(s)\\n\\tarr = []\\n\\tans = 0\\n\\tdp = [0] * (n + 1)\\n\\tfor i in range(1, n + 1):\\n\\t\\tdp[i] = (dp[i - 1] + pow(10, i - 1, mod) * i % mod) % mod\\n\\tfor i in range(n):\\n\\t\\tbefore = i\\n\\t\\tafter = n - i - 1\\n\\t\\tcur_pow = after\\n\\t\\tvalue = int(s[i]) * pow(10, cur_pow, mod) % mod\\n\\t\\tvalue2 = before * (before + 1) // 2 % mod\\n\\t\\tans = (ans + int(s[i]) * dp[after]) % mod\\n\\t\\tans = ans + value * value2 % mod\\n\\tans = ans % mod\\n\\tout(ans)\\n\", \"MOD = 10 ** 9 + 7\\ndigits = [int(x) for x in input()]\\nn = len(digits)\\nleft = [0 for _ in range(n)]\\nright = [0 for _ in range(n)]\\ntot = 0\\nl = 0\\nfor i in range(n):\\n\\tl = l * 10 % MOD\\n\\tl = (l + digits[i]) % MOD\\n\\ttot = (tot + l) % MOD\\n\\tleft[i] = tot\\nr = 0\\nm = 1\\nfor i in range(n - 1, -1, -1):\\n\\tr = (r + digits[i] * m % MOD) % MOD\\n\\tright[i] = r\\n\\tm = m * 10 % MOD\\nans = 0\\nif n > 1:\\n\\tans += right[1]\\n\\tans %= MOD\\nfor i in range(1, n - 1):\\n\\tleftCounts = i + 1\\n\\tans += left[i - 1] * pow(10, n - i - 1, MOD) + leftCounts % MOD * right[i + 1] % MOD % MOD\\n\\tans %= MOD\\nif n > 1:\\n\\tans += left[n - 2]\\nans %= MOD\\nprint(ans)\\n\", \"MOD = 10 ** 9 + 7\\ndigits = [int(x) for x in input()]\\nn = len(digits)\\nright = [0 for _ in range(n)]\\nr = 0\\nmul = 1\\nfor i in range(n - 1, -1, -1):\\n\\tr += digits[i] * mul\\n\\tmul *= 10\\n\\tmul %= MOD\\n\\tr %= MOD\\n\\tright[i] = r\\nleft = [0 for _ in range(n)]\\nl = 0\\ntot = 0\\nfor i in range(n):\\n\\tl *= 10\\n\\tl += digits[i]\\n\\tl %= MOD\\n\\ttot += l\\n\\ttot %= MOD\\n\\tleft[i] = tot\\nans = 0\\nfor rr in range(1, n + 1):\\n\\tleftIdx = rr - 2\\n\\tif leftIdx == -1 and rr == n:\\n\\t\\tbreak\\n\\tif leftIdx == -1:\\n\\t\\tans += 1 * right[rr]\\n\\t\\tans %= MOD\\n\\telif rr == n:\\n\\t\\tnLeft = leftIdx + 2\\n\\t\\tans += left[leftIdx]\\n\\t\\tans %= MOD\\n\\telse:\\n\\t\\tnLeft = leftIdx + 2\\n\\t\\tans += left[leftIdx] % MOD * pow(10, n - rr, MOD) + nLeft * right[rr] % MOD\\n\\t\\tans %= MOD\\nprint(ans)\\n\", \"from __future__ import division, print_function\\nimport bisect\\nimport math\\nimport heapq\\nimport itertools\\nimport sys\\nfrom collections import deque\\nfrom atexit import register\\nfrom collections import Counter\\nfrom functools import reduce\\nif sys.version_info[0] < 3:\\n\\tfrom io import BytesIO as stream\\nelse:\\n\\tfrom io import StringIO as stream\\nif sys.version_info[0] < 3:\\n\\n\\tclass dict(dict):\\n\\n\\t\\tdef items(self):\\n\\t\\t\\treturn dict.iteritems(self)\\n\\n\\t\\tdef keys(self):\\n\\t\\t\\treturn dict.iterkeys(self)\\n\\n\\t\\tdef values(self):\\n\\t\\t\\treturn dict.itervalues(self)\\n\\tinput = raw_input\\n\\trange = xrange\\n\\tfilter = itertools.ifilter\\n\\tmap = itertools.imap\\n\\tzip = itertools.izip\\n\\ndef sync_with_stdio(sync=True):\\n\\tglobal input, flush\\n\\tif sync:\\n\\t\\tflush = sys.stdout.flush\\n\\telse:\\n\\t\\tsys.stdin = stream(sys.stdin.read())\\n\\t\\tinput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\n\\t\\tsys.stdout = stream()\\n\\t\\tregister(lambda : sys.__stdout__.write(sys.stdout.getvalue()))\\n\\ndef main():\\n\\tmod = 10 ** 9\\n\\tmod += 7\\n\\ts = input()\\n\\tn = len(s)\\n\\tpeeche = [0] * n\\n\\taage = [0] * n\\n\\tfor i in range(1, n):\\n\\t\\tpeeche[i] = i * (i + 1) // 2\\n\\t\\tpeeche[i] *= pow(10, n - i - 1, mod)\\n\\t\\tpeeche[i] %= mod\\n\\tfor i in range(n - 1):\\n\\t\\taage[0] += (i + 1) * pow(10, i, mod)\\n\\t\\taage[i] %= mod\\n\\tfor i in range(1, n):\\n\\t\\taage[i] = aage[i - 1]\\n\\t\\taage[i] -= (n - i) * pow(10, n - i - 1, mod)\\n\\t\\taage[i] %= mod\\n\\tans = 0\\n\\tfor i in range(n):\\n\\t\\tans += int(s[i]) * (peeche[i] + aage[i])\\n\\t\\tans %= mod\\n\\tprint(ans % mod)\\nsync_with_stdio(False)\\nmain()\\n\", \"from sys import stdin\\ninput = lambda : stdin.readline().strip()\\nlin = lambda : list(map(int, input().split()))\\niin = lambda : int(input())\\nmain = lambda : map(int, input().split())\\nfrom math import ceil, sqrt, factorial, log\\nfrom collections import deque\\nfrom bisect import bisect_left\\nmod = 998244353\\nmod = 1000000007\\n\\ndef gcd(a, b):\\n\\t(a, b) = (max(a, b), min(a, b))\\n\\twhile a % b != 0:\\n\\t\\t(a, b) = (b, a % b)\\n\\treturn b\\n\\ndef moduloinverse(a):\\n\\treturn pow(a, mod - 2, mod)\\n\\ndef solve(we):\\n\\ts = input()\\n\\tans = 0\\n\\tsu = 0\\n\\tdecim = 1\\n\\trep = 1\\n\\tlast = len(s) - 1\\n\\tfor i in range(len(s) - 1):\\n\\t\\tsu += int(s[i])\\n\\tfor i in range(len(s) - 2, -1, -1):\\n\\t\\tz = int(s[i + 1]) * (last * (last + 1) // 2) + rep * su\\n\\t\\tans = (ans + z * decim) % mod\\n\\t\\tlast -= 1\\n\\t\\trep += 1\\n\\t\\tsu -= int(s[i])\\n\\t\\tdecim = decim * 10 % mod\\n\\tprint(ans % mod)\\nqwe = 1\\nfor _ in range(qwe):\\n\\tsolve(_ + 1)\\n\", \"import sys\\nsys.setrecursionlimit(10 ** 5)\\nint1 = lambda x: int(x) - 1\\np2D = lambda x: print(*x, sep='\\\\n')\\n\\ndef II():\\n\\treturn int(sys.stdin.buffer.readline())\\n\\ndef MI():\\n\\treturn map(int, sys.stdin.buffer.readline().split())\\n\\ndef LI():\\n\\treturn list(map(int, sys.stdin.buffer.readline().split()))\\n\\ndef LLI(rows_number):\\n\\treturn [LI() for _ in range(rows_number)]\\n\\ndef BI():\\n\\treturn sys.stdin.buffer.readline()[:-1]\\n\\ndef SI():\\n\\treturn sys.stdin.buffer.readline()[:-1].decode()\\nmd = 10 ** 9 + 7\\nmx = 10 ** 5 + 5\\ncc = [0]\\nten = [1]\\nfor _ in range(mx):\\n\\tten.append(ten[-1] * 10 % md)\\nfor i in range(mx):\\n\\tcc.append((cc[-1] + ten[i] * (i + 1)) % md)\\ns = input()\\nn = len(s)\\nans = 0\\nfor (i, a) in enumerate(s):\\n\\ta = int(a)\\n\\tans += a * (cc[n - i - 1] + ten[n - i - 1] * i * (i + 1) // 2)\\n\\tans %= md\\nprint(ans)\\n\", \"import sys\\ninput = sys.stdin.readline\\nfrom itertools import accumulate\\nS = input().strip()\\nmod = 10 ** 9 + 7\\nLEN = len(S)\\nANS = [0] * (LEN + 1)\\nANS2 = [0] * (LEN + 1)\\nANS3 = [0] * (LEN + 1)\\nfor i in range(LEN):\\n\\tx = int(S[LEN - 1 - i])\\n\\tk = LEN - i - 1\\n\\tp = k * (k + 1) // 2\\n\\tANS[i] += x * p\\n\\tANS2[0] += x\\n\\tANS2[i] -= x\\n\\tANS3[i] -= i * x\\nANS2 = list(accumulate(ANS2))\\nfor i in range(LEN + 1):\\n\\tANS2[i] += ANS3[i]\\nANS2 = list(accumulate(ANS2))\\nA = 0\\nfor i in range(LEN):\\n\\tA += (ANS[i] + ANS2[i]) * pow(10, i, mod)\\n\\tA %= mod\\nprint(A)\\n\", \"def main():\\n\\tmod = 10 ** 9 + 7\\n\\ts = input()\\n\\tn = len(s)\\n\\tdpl = [0] * (n + 1)\\n\\tdpr = [0] * (n + 1)\\n\\tpow10 = [1] * (n + 1)\\n\\tfor i in range(1, n + 1):\\n\\t\\tpow10[i] = 10 * pow10[i - 1] % mod\\n\\tfor i in range(n):\\n\\t\\tv = int(s[i])\\n\\t\\tdpl[i + 1] = (10 * dpl[i] + v) % mod\\n\\tfor i in range(n):\\n\\t\\tv = int(s[-(i + 1)])\\n\\t\\tdpr[i + 1] = (pow10[i] * v + dpr[i]) % mod\\n\\tans = 0\\n\\tfor i in range(n + 1):\\n\\t\\tans += (n - i) * dpr[i]\\n\\t\\tans %= mod\\n\\ts = 0\\n\\tfor i in range(n):\\n\\t\\ts += dpl[i]\\n\\t\\tans += pow10[n - 1 - i] * s\\n\\t\\tans %= mod\\n\\tprint(ans % mod)\\n\\treturn\\nmain()\\n\", \"MOD = 10 ** 9 + 7\\ns = input()\\nans = 0\\nnv = 0\\nsv = 0\\nfor i in range(len(s)):\\n\\td = ord(s[i]) - 48\\n\\tk = (i * (i + 1) // 2 + 1) % MOD\\n\\tans = (ans * 10 + d * k + sv) % MOD\\n\\tnv = (nv * 10 + d) % MOD\\n\\tsv += nv\\nans = (ans - nv) % MOD\\nif ans < 0:\\n\\tans += MOD\\nprint(ans)\\n\", \"mod = 1000000007\\ns = input()\\nans = 0\\nfor i in range(len(s)):\\n\\tans += i * (i + 1) // 2 * (int(s[i]) * pow(10, len(s) - i - 1, mod))\\n\\tans %= mod\\ncurrent = 0\\nfor i in range(len(s) - 1, 0, -1):\\n\\tcurrent += int(s[len(s) - i - 1])\\n\\tans += i * current * pow(10, i - 1, mod)\\n\\tans %= mod\\nprint(ans)\\n\", \"import sys\\nimport random\\nfrom fractions import Fraction\\nfrom math import *\\n\\ndef input():\\n\\treturn sys.stdin.readline().strip()\\n\\ndef iinput():\\n\\treturn int(input())\\n\\ndef finput():\\n\\treturn float(input())\\n\\ndef tinput():\\n\\treturn input().split()\\n\\ndef linput():\\n\\treturn list(input())\\n\\ndef rinput():\\n\\treturn map(int, tinput())\\n\\ndef fiinput():\\n\\treturn map(float, tinput())\\n\\ndef rlinput():\\n\\treturn list(map(int, input().split()))\\n\\ndef trinput():\\n\\treturn tuple(rinput())\\n\\ndef srlinput():\\n\\treturn sorted(list(map(int, input().split())))\\n\\ndef NOYES(fl):\\n\\tif fl:\\n\\t\\tprint('NO')\\n\\telse:\\n\\t\\tprint('YES')\\n\\ndef YESNO(fl):\\n\\tif fl:\\n\\t\\tprint('YES')\\n\\telse:\\n\\t\\tprint('NO')\\n\\ndef main():\\n\\ts = input()\\n\\tn = len(s)\\n\\tmod = int(1000000000.0) + 7\\n\\tq = [0 for i in range(100100)]\\n\\tw = [0 for i in range(100100)]\\n\\tq[0] = 1\\n\\tw[0] = 1\\n\\tres = 1\\n\\tfor i in range(1, 100100):\\n\\t\\tres = res * 10 % mod\\n\\t\\tq[i] = q[i - 1] + res\\n\\t\\tq[i] %= mod\\n\\t\\tw[i] = w[i - 1] * 10\\n\\t\\tw[i] %= mod\\n\\t(l, res, r) = (0, 0, 0)\\n\\tfor i in range(n - 1):\\n\\t\\tl *= 10\\n\\t\\tl += int(s[i])\\n\\t\\tl %= mod\\n\\t\\tres += l * q[n - 2 - i] % mod\\n\\t\\tres %= mod\\n\\tfor i in range(n - 1, 0, -1):\\n\\t\\tr += w[n - 1 - i] * int(s[i])\\n\\t\\tr %= mod\\n\\t\\tres += r * i % mod\\n\\t\\tres %= mod\\n\\tprint(res)\\nfor i in range(1):\\n\\tmain()\\n\", \"mod = 10 ** 9 + 7\\n\\ndef main():\\n\\tnum = input()\\n\\tn = len(num)\\n\\ts = 0\\n\\tc = 0\\n\\tk = 0\\n\\tfor i in reversed(num):\\n\\t\\tc += int(i) * pow(10, k, mod)\\n\\t\\tc = c % mod\\n\\t\\ts += (n - k - 1) * c\\n\\t\\ts = s % mod\\n\\t\\tk += 1\\n\\tc = 0\\n\\tk = n - 1\\n\\tfor i in num:\\n\\t\\tc = c * 10 + int(i)\\n\\t\\tc = c % mod\\n\\t\\ts += c * (pow(10, k, mod) - 1) * 111111112\\n\\t\\ts = s % mod\\n\\t\\tk -= 1\\n\\tprint(s)\\nmain()\\n\", \"MOD = 10 ** 9 + 7\\nN = input()\\nn = len(N)\\npowers = [1] * n\\nrhs = [0] * n\\nlhs = [0] * n\\nfor i in range(1, n):\\n\\tpowers[i] = powers[i - 1] * 10 % MOD\\n\\trhs[i] = (rhs[i - 1] + powers[i - 1] * i) % MOD\\n\\tlhs[i] = i * (i + 1) // 2 % MOD\\nresult = 0\\nfor i in range(n):\\n\\tnum = ord(N[i]) - ord('0')\\n\\tresult = (result + num * (powers[n - 1 - i] * lhs[i] % MOD + rhs[n - 1 - i])) % MOD\\nprint(result)\\n\", \"s = str(input())\\na = len(s)\\nz = 10 ** 9 + 7\\nif a == 1:\\n\\tprint(0)\\nelse:\\n\\tlis = []\\n\\tpower = [1]\\n\\tfor i in range(1, a):\\n\\t\\tif i != 1:\\n\\t\\t\\tpower.append(power[-1] * 10 % z)\\n\\t\\tlis.append(power[-1] * i % z)\\n\\tpref = [lis[0]]\\n\\tfor i in range(1, a - 1):\\n\\t\\tpref.append((pref[-1] + lis[i]) % z)\\n\\tans = 0\\n\\tfor i in range(a):\\n\\t\\tback = i\\n\\t\\tfront = a - i - 1\\n\\t\\tif i > 0:\\n\\t\\t\\ttemp = back * (back + 1) // 2 * power[front]\\n\\t\\t\\ttemp %= z\\n\\t\\t\\ttemp *= int(s[i])\\n\\t\\t\\ttemp %= z\\n\\t\\t\\tans += temp\\n\\t\\t\\tans %= z\\n\\t\\tif i < a - 1:\\n\\t\\t\\ttemp = pref[-i - 1]\\n\\t\\t\\ttemp *= int(s[i])\\n\\t\\t\\ttemp %= z\\n\\t\\t\\tans += temp\\n\\t\\t\\tans %= z\\n\\tprint(ans)\\n\", \"s = list(map(int, input()))\\nans = 0\\nmod = 10 ** 9 + 7\\nn = len(s)\\ns.reverse()\\nx = 0\\npower = [1]\\nfor r in range(n):\\n\\tpower.append(power[-1] * 10 % mod)\\nfor (r, d) in enumerate(s):\\n\\tl = n - r - 1\\n\\tans += l * (l + 1) // 2 % mod * (d * power[r] % mod) % mod\\n\\tans %= mod\\n\\tans += d * x % mod\\n\\tans %= mod\\n\\tx += power[r] * ((r + 1) % mod) % mod\\n\\tans %= mod\\n\\tx %= mod\\nprint(ans % mod)\\n\", \"mod = 10 ** 9 + 7\\nde = [1]\\nfor i in range(10 ** 5 + 10):\\n\\tde.append(de[-1] * 10 % mod)\\nde1 = [0, 1]\\nfor i in range(1, 10 ** 5 + 10):\\n\\tde1.append(de1[-1] + de[i])\\n\\tde1[-1] %= mod\\ns = input()\\nn = len(s)\\nnw = 0\\nans = 0\\nfor i in range(n):\\n\\tnw = nw * 10 + ord(s[i]) - ord('0')\\n\\tnw %= mod\\n\\tans += nw * de1[n - i - 1]\\n\\tans %= mod\\nnw = 0\\nfor i in range(n - 1, -1, -1):\\n\\tnw += de[n - 1 - i] * (ord(s[i]) - ord('0'))\\n\\tnw %= mod\\n\\tans += nw * i\\n\\tans %= mod\\nprint(ans)\\n\", \"N = 100005\\nINF = 1000000007\\npwr = [0] * N\\nsm = [0] * N\\npwr[0] = 1\\nfor i in range(1, N):\\n\\tpwr[i] = pwr[i - 1] * 10 % INF\\ns = input('')\\nn = len(s)\\nfor i in range(n - 1, -1, -1):\\n\\tsm[i] = int(s[i])\\n\\tsm[i] = (sm[i + 1] + sm[i] * pwr[n - i - 1]) % INF\\nfor i in range(n - 1, -1, -1):\\n\\tsm[i] += sm[i + 1]\\n\\tif sm[i] >= INF:\\n\\t\\tsm[i] -= INF\\nfor i in range(1, N - 1):\\n\\tpwr[i] += pwr[i - 1]\\n\\tif pwr[i] >= INF:\\n\\t\\tpwr[i] -= INF\\nans = 0\\ntmp = 0\\nfor i in range(n):\\n\\tans = (ans + tmp * pwr[n - i - 1] + sm[i + 1]) % INF\\n\\ttmp = (tmp * 10 + int(s[i])) % INF\\nprint(ans)\\n\", \"a = input()\\nn = len(a)\\nmod = 1000000000 + 7\\ntmod = [0 for i in range(n)]\\ntmod[0] = 1\\nfor i in range(1, n):\\n\\ttmod[i] = tmod[i - 1] * 10 % mod\\nst = [0 for i in range(max(n, 2))]\\nst[1] = 1\\nfor i in range(2, n):\\n\\tst[i] = (st[i - 1] + tmod[i - 1]) % mod\\ncu = [0 for i in range(max(n, 3))]\\ncu[2] = 1\\nfor i in range(3, n):\\n\\tcu[i] = (cu[i - 1] * 10 % mod + i - 1) % mod\\nans = 0\\nfor k in range(n):\\n\\td = int(a[n - 1 - k])\\n\\ts = 0\\n\\ts += k * st[k] % mod\\n\\ts -= cu[k]\\n\\ts %= mod\\n\\ts += (n - 1 - k) * (n - k) // 2 % mod * tmod[k]\\n\\ts %= mod\\n\\tans += s * d % mod\\n\\tans %= mod\\nprint(ans)\\n\", \"def discount(num):\\n\\tmo = 10 ** 9 + 7\\n\\tv = 0\\n\\ts = str(num)\\n\\t(v1, s1) = (0, 0)\\n\\t(v2, s2) = (0, 0)\\n\\tfor i in range(len(s)):\\n\\t\\tc = int(s[i])\\n\\t\\tv2 = (10 * v2 + 10 * v1 + (s2 + s1) * c) % mo\\n\\t\\ts2 = s2 + s1\\n\\t\\tv1 = (v1 + v) % mo\\n\\t\\ts1 = s1 + 1\\n\\t\\tv = (v * 10 + c) % mo\\n\\treturn (v1 + v2) % mo\\nprint(discount(int(input())))\\n\", \"import time, math as mt, bisect as bs, sys\\nfrom sys import stdin, stdout\\nfrom collections import deque\\nfrom fractions import Fraction\\nfrom collections import Counter\\nfrom collections import OrderedDict\\npi = 3.141592653589793\\n\\ndef II():\\n\\treturn int(stdin.readline())\\n\\ndef IP():\\n\\treturn map(int, stdin.readline().split())\\n\\ndef L():\\n\\treturn list(map(int, stdin.readline().split()))\\n\\ndef P(x):\\n\\treturn stdout.write(str(x) + '\\\\n')\\n\\ndef PI(x, y):\\n\\treturn stdout.write(str(x) + ' ' + str(y) + '\\\\n')\\n\\ndef lcm(a, b):\\n\\treturn a * b // gcd(a, b)\\n\\ndef gcd(a, b):\\n\\tif a == 0:\\n\\t\\treturn b\\n\\telif b == 0:\\n\\t\\treturn a\\n\\tif a > b:\\n\\t\\treturn gcd(a % b, b)\\n\\telse:\\n\\t\\treturn gcd(a, b % a)\\n\\ndef bfs(adj, v):\\n\\tvisited = [False] * (v + 1)\\n\\tq = deque()\\n\\twhile q:\\n\\t\\tpass\\n\\ndef sieve():\\n\\tli = [True] * (2 * 10 ** 5 + 5)\\n\\t(li[0], li[1]) = (False, False)\\n\\tfor i in range(2, len(li), 1):\\n\\t\\tif li[i] == True:\\n\\t\\t\\tfor j in range(i * i, len(li), i):\\n\\t\\t\\t\\tli[j] = False\\n\\tprime = []\\n\\tfor i in range(2 * 10 ** 5 + 5):\\n\\t\\tif li[i] == True:\\n\\t\\t\\tprime.append(i)\\n\\treturn prime\\n\\ndef setBit(n):\\n\\tcount = 0\\n\\twhile n != 0:\\n\\t\\tn = n & n - 1\\n\\t\\tcount += 1\\n\\treturn count\\nmx = 10 ** 7\\nspf = [mx] * (mx + 1)\\n\\ndef SPF():\\n\\tspf[1] = 1\\n\\tfor i in range(2, mx + 1):\\n\\t\\tif spf[i] == mx:\\n\\t\\t\\tspf[i] = i\\n\\t\\t\\tfor j in range(i * i, mx + 1, i):\\n\\t\\t\\t\\tif i < spf[j]:\\n\\t\\t\\t\\t\\tspf[j] = i\\n\\treturn\\n\\ndef readTree(n, e):\\n\\tadj = [set() for i in range(n + 1)]\\n\\tfor i in range(e):\\n\\t\\t(u1, u2) = IP()\\n\\t\\tadj[u1].add(u2)\\n\\treturn adj\\nmod = 10 ** 9 + 7\\n\\ndef solve():\\n\\tn = input()\\n\\tll = len(n)\\n\\tmod10 = [1] * (10 ** 5 + 20)\\n\\tmod10[1] = 10\\n\\tfor i in range(2, len(mod10)):\\n\\t\\tmod10[i] = mod10[i - 1] * 10 % mod\\n\\tpref_mod10 = [0] * (10 ** 5 + 20)\\n\\tpref_mod10[1] = mod10[1]\\n\\tfor i in range(2, len(mod10)):\\n\\t\\tpref_mod10[i] = (pref_mod10[i - 1] % mod + mod10[i] % mod) % mod\\n\\tour = [1] * (ll + 1)\\n\\tour[1] = int(n[0])\\n\\tcur = 1\\n\\tfor i in range(2, ll + 1):\\n\\t\\tour[i] = (our[i - 1] * 10 + int(n[cur])) % mod\\n\\t\\tcur += 1\\n\\tour_rev = [1] * (ll + 1)\\n\\tour_rev[ll] = int(n[-1])\\n\\tcur = ll - 2\\n\\tlast = 10\\n\\tfor i in range(ll - 1, 0, -1):\\n\\t\\tour_rev[i] = (int(n[cur]) * last + our_rev[i + 1]) % mod\\n\\t\\tcur -= 1\\n\\t\\tlast = last * 10 % mod\\n\\tpref = [0] * (ll + 1)\\n\\tpref[1] = our_rev[1]\\n\\tfor i in range(2, ll + 1):\\n\\t\\tpref[i] = (pref[i - 1] + our_rev[i]) % mod\\n\\tans = 0\\n\\tfor i in range(1, ll):\\n\\t\\tsm = (pref[ll] - pref[i + 1] + mod) % mod\\n\\t\\tlenl = ll - (i + 1)\\n\\t\\tgt = pref_mod10[lenl]\\n\\t\\tp1 = our[i] % mod * gt % mod % mod\\n\\t\\tans += (p1 + sm) % mod\\n\\tans += (pref[ll] - pref[1] + mod) % mod % mod\\n\\tfor i in range(1, ll):\\n\\t\\tans = (ans + our[i]) % mod\\n\\tprint(ans)\\n\\treturn\\nt = 1\\nfor i in range(t):\\n\\tsolve()\\n\", \"import sys\\nsys.setrecursionlimit(10 ** 5)\\nnum = input()\\nn = len(num)\\nans = 0\\nmod = 1000000007\\ntis = [0] * n\\nsim = int(num[0])\\nfor i in range(1, n):\\n\\ttis[i] = (n - i) * sim + i * (i + 1) // 2 * int(num[i])\\n\\tsim = sim + int(num[i])\\nten = [1]\\nfor _ in range(n):\\n\\tten.append(ten[-1] * 10 % mod)\\nfor i in range(n):\\n\\tans = (ans + tis[n - 1 - i] * ten[i]) % mod\\nprint(ans)\\n\", \"from collections import Counter, OrderedDict\\nfrom itertools import permutations as perm\\nfrom sys import setrecursionlimit\\nfrom collections import deque\\nfrom sys import stdin\\nfrom bisect import *\\nfrom heapq import *\\nimport threading\\nimport math\\ng = lambda : stdin.readline().strip()\\ngl = lambda : g().split()\\ngil = lambda : [int(var) for var in gl()]\\ngfl = lambda : [float(var) for var in gl()]\\ngcl = lambda : list(g())\\ngbs = lambda : [int(var) for var in g()]\\nmod = int(1000000000.0) + 7\\ninf = float('inf')\\na = gbs()\\nn = len(a)\\np10 = [1]\\nfor i in range(1, n):\\n\\tp10.append(10 * p10[-1] % mod)\\np = [1]\\nfor i in range(1, n):\\n\\tv = (i + 1) * p10[i] % mod + p[-1]\\n\\tp.append(v % mod)\\np.append(0)\\nans = 0\\nfor i in range(n):\\n\\t(l, r) = (i, n - 1 - i)\\n\\tc = (l * (l + 1) // 2 % mod * p10[r] % mod + p[r - 1]) % mod\\n\\tans += c * a[i] % mod\\n\\tans %= mod\\nprint(ans)\\n\", \"from bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nfrom heapq import heappush, heappop, heapify\\nimport math\\nfrom collections import *\\nfrom functools import reduce, cmp_to_key\\nimport sys\\ninput = sys.stdin.readline\\nfrom itertools import accumulate\\nfrom functools import lru_cache\\nM = mod = 10 ** 9 + 7\\n\\ndef factors(n):\\n\\treturn sorted(set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0))))\\n\\ndef inv_mod(n):\\n\\treturn pow(n, mod - 2, mod)\\n\\ndef li():\\n\\treturn [int(i) for i in input().rstrip('\\\\n').split()]\\n\\ndef st():\\n\\treturn input().rstrip('\\\\n')\\n\\ndef val():\\n\\treturn int(input().rstrip('\\\\n'))\\n\\ndef li2():\\n\\treturn [i for i in input().rstrip('\\\\n')]\\n\\ndef li3():\\n\\treturn [int(i) for i in input().rstrip('\\\\n')]\\nl = li3()\\nans = last = 0\\nl1 = [0]\\nfor i in l:\\n\\tl1.append(l1[-1] * 10 + i)\\n\\tl1[-1] = l1[-1] % mod\\nhel = [0]\\nfor i in range(len(l) - 1):\\n\\thel.append((hel[-1] * 10 + 1) % mod)\\nhel.reverse()\\nl2 = []\\nfor i in range(len(l)):\\n\\tl2.append(l1[i + 1] * hel[i] % mod)\\nhelpl = [0]\\nfor i in range(len(l) - 1, -1, -1):\\n\\thelpl.append(helpl[-1] + l[i] * pow(10, len(l) - i - 1, mod))\\n\\thelpl[-1] = helpl[-1] % mod\\nhelpl.reverse()\\nl3 = []\\nfor i in range(1, len(l)):\\n\\tl3.append(helpl[i] * i % mod)\\nl2.append(0)\\nans = 0\\nl3.append(0)\\nfor i in l2 + l3:\\n\\tans = (ans + i) % mod\\nprint(ans)\\n\", \"s = input()\\nn = len(s)\\nm = 1000000007\\nans = 0\\nten = [1] * (n + 1)\\nleft = [0] * (n + 1)\\nfor i in range(1, n + 1):\\n\\tten[i] = ten[i - 1] * 10 % m\\n\\tleft[i] = (left[i - 1] + ten[i - 1] * i) % m\\nsol = 0\\nfor i in range(n):\\n\\tsol = (sol + (left[n - i - 1] + (i * i + i * 1) // 2 * ten[n - i - 1]) * int(s[i])) % m\\nprint(sol % m)\\n\", \"import sys\\n\\ndef minp():\\n\\treturn sys.stdin.readline().strip()\\n\\ndef mint():\\n\\treturn int(minp())\\n\\ndef mints():\\n\\treturn map(int, minp().split())\\n\\ndef solve():\\n\\tMOD = int(1000000000.0 + 7)\\n\\ts = minp()\\n\\tn = len(s)\\n\\tp = [0] * (n + 1)\\n\\tpp = [1] * (n + 1)\\n\\tp10 = 1\\n\\tfor i in range(1, n + 1):\\n\\t\\tp[i] = (p[i - 1] + p10 * i) % MOD\\n\\t\\tpp[i] = p10\\n\\t\\tp10 = p10 * 10 % MOD\\n\\tres = int(s[0]) * p[n - 1] % MOD\\n\\tfor i in range(1, n):\\n\\t\\tres = (res + int(s[i]) * (p[n - 1 - i] + pp[n - i] * i * (i + 1) // 2)) % MOD\\n\\tprint(res)\\nsolve()\\n\", \"import sys\\ninput = sys.stdin.readline\\nI = lambda : list(map(int, input().split()))\\ns = input().strip()\\nmd = 10 ** 9 + 7\\nn = len(s)\\nan = 0\\nx = 0\\nar = [1, 20]\\npr = 100\\nfor i in range(2, 10 ** 5 + 5):\\n\\tar.append((i + 1) * pr % md)\\n\\tpr = pr * 10 % md\\nfor i in range(1, len(ar)):\\n\\tar[i] = (ar[i] + ar[i - 1]) % md\\nar += [1]\\nif n > 2:\\n\\tfor i in range(n):\\n\\t\\tx = i * (i + 1) // 2\\n\\t\\tif i == 0:\\n\\t\\t\\tx = 1\\n\\t\\tif i == 1:\\n\\t\\t\\tx = 2\\n\\t\\tct = n - i - 2\\n\\t\\tcr = ar[ct] * int(s[i]) % md\\n\\t\\tcr = (cr + (x - (1 if i < 2 or i == n - 1 else 0)) * int(s[i]) * pow(10, n - i - 1, md)) % md\\n\\t\\tan = (an + cr) % md\\n\\tprint(an)\\nelif n == 1:\\n\\tprint(0)\\nelse:\\n\\tprint(int(s[0]) + int(s[1]))\\n\", \"s = input()\\nn = len(s)\\nmod = 10 ** 9 + 7\\ndp = [0 for _ in range(n)]\\nten = [1 for _ in range(n + 1)]\\nfor i in range(1, n + 1):\\n\\tten[i] = ten[i - 1] * 10 % mod\\nres = 0\\nfor i in range(n - 2, -1, -1):\\n\\tdp[i] = (n - i - 1) * ten[n - i - 2] + dp[i + 1]\\nfor i in range(n):\\n\\tdp[i] += i * (i + 1) // 2 * ten[n - i - 1]\\n\\tres += int(s[i]) * dp[i] % mod\\nprint(res % mod)\\n\", \"s = list(map(int, list(input())))\\nmod_const = 10 ** 9 + 7\\nl_const = len(s)\\nres = 0\\ndischarge = 1\\nrepeat = (l_const - 1) * l_const // 2\\nmultiplier = 0\\nfor i in range(l_const - 1, -1, -1):\\n\\tres += discharge * s[i] * repeat\\n\\tres += multiplier * s[i]\\n\\tmultiplier += discharge * (l_const - i)\\n\\tmultiplier %= mod_const\\n\\tdischarge *= 10\\n\\tdischarge %= mod_const\\n\\trepeat -= i\\nprint(res % mod_const)\\n\", \"s = input()\\nmod = 10 ** 9 + 7\\nn = len(s)\\na = [int(s[n - i - 1]) for i in range(n)]\\ns = [0] * (n + 1)\\nfor i in range(n):\\n\\ts[i + 1] = s[i] + i + 1\\nss = [0] * (n + 1)\\nss[0] = 1\\nfor i in range(n):\\n\\tss[i + 1] = ss[i] + (i + 2) * pow(10, i + 1, mod)\\nans = 0\\nfor i in range(n):\\n\\tif i != n - 1:\\n\\t\\tans += s[n - i - 1] * a[i] * pow(10, i, mod)\\n\\t\\tans %= mod\\n\\tif i != 0:\\n\\t\\tans += ss[i - 1] * a[i]\\n\\t\\tans %= mod\\nprint(ans)\\n\", \"import sys\\ninput = lambda : sys.stdin.readline().rstrip()\\nm = 10 ** 9 + 7\\na = input()\\nn = len(a)\\np = 0\\nans = 0\\nfor i in range(n - 1, -1, -1):\\n\\tc = pow(10, n - i - 1, m)\\n\\tval = c * int(a[i]) * i * (i + 1) // 2\\n\\tval %= m\\n\\tif i != n - 1:\\n\\t\\tp = (p + pow(10, n - 2 - i, m) * (n - i - 1)) % m\\n\\tval += p * int(a[i])\\n\\tval %= m\\n\\tans = (ans + val) % m\\nprint(ans)\\n\", \"mod = 10 ** 9 + 7\\ns = input()\\nn = len(s)\\ndp = [0] * n\\ndp[0] = 0\\nval = ord(s[0]) - ord('0')\\ntotal_val = val\\nfor i in range(1, n):\\n\\tdp[i] = 10 * dp[i - 1] + (ord(s[i]) - ord('0')) * (i * (i + 1) // 2)\\n\\tdp[i] += total_val\\n\\tval *= 10\\n\\tval += ord(s[i]) - ord('0')\\n\\ttotal_val += val\\n\\tval %= mod\\n\\ttotal_val %= mod\\n\\tdp[i] %= mod\\nprint(dp[n - 1])\\n\", \"from sys import stdin, stdout\\nimport math\\ninput = stdin.readline\\nst = input()\\nn = len(st)\\nn -= 1\\narr = [0, 1]\\nmod = int(1000000000.0 + 7)\\ni = 1\\nfor j in range(2, n):\\n\\ti = i * 10 % mod\\n\\tarr.append(j % mod * i % mod % mod)\\npo = []\\ni = 1\\nfor j in range(n):\\n\\tpo.append(i)\\n\\ti = i * 10 % mod\\nmain = [arr[0]]\\nfor i in range(n - 1):\\n\\tmain.append((main[i] % mod + arr[i + 1] % mod) % mod)\\nmain = main[::-1]\\nans = 0\\nfor i in range(n):\\n\\tans += int(st[i]) * po[n - 1 - i] * int(i * (i + 1) / 2) + int(st[i]) * main[i]\\n\\tans = ans % mod\\nprint(ans)\\n\", \"import sys, bisect, string, math, time, functools, random, fractions\\nfrom heapq import heappush, heappop, heapify\\nfrom collections import deque, defaultdict, Counter\\nfrom itertools import permutations, combinations, groupby\\nrep = range\\nR = range\\n\\ndef Golf():\\n\\t(n, *t) = map(int, open(0).read().split())\\n\\ndef I():\\n\\treturn int(input())\\n\\ndef S_():\\n\\treturn input()\\n\\ndef IS():\\n\\treturn input().split()\\n\\ndef LS():\\n\\treturn [i for i in input().split()]\\n\\ndef MI():\\n\\treturn map(int, input().split())\\n\\ndef LI():\\n\\treturn [int(i) for i in input().split()]\\n\\ndef LI_():\\n\\treturn [int(i) - 1 for i in input().split()]\\n\\ndef NI(n):\\n\\treturn [int(input()) for i in range(n)]\\n\\ndef NI_(n):\\n\\treturn [int(input()) - 1 for i in range(n)]\\n\\ndef NLI(n):\\n\\treturn [[int(i) for i in input().split()] for i in range(n)]\\n\\ndef NLI_(n):\\n\\treturn [[int(i) - 1 for i in input().split()] for i in range(n)]\\n\\ndef StoLI():\\n\\treturn [ord(i) - 97 for i in input()]\\n\\ndef ItoS(n):\\n\\treturn chr(n + 97)\\n\\ndef LtoS(ls):\\n\\treturn ''.join([chr(i + 97) for i in ls])\\n\\ndef RA():\\n\\treturn map(int, open(0).read().split())\\n\\ndef RLI(n=8, a=1, b=10):\\n\\treturn [random.randint(a, b) for i in range(n)]\\n\\ndef RI(a=1, b=10):\\n\\treturn random.randint(a, b)\\n\\ndef INP():\\n\\tN = 10\\n\\tA = 10\\n\\tn = random.randint(1, N)\\n\\ta = [random.randint(1, A) for i in range(n)]\\n\\treturn (n, a)\\n\\ndef Rtest(T):\\n\\t(case, err) = (0, 0)\\n\\tfor i in range(T):\\n\\t\\tinp = INP()\\n\\t\\ta1 = naive(*inp)\\n\\t\\ta2 = solve(*inp)\\n\\t\\tif a1 != a2:\\n\\t\\t\\tprint((a1, a2), inp)\\n\\t\\t\\terr += 1\\n\\t\\tcase += 1\\n\\tprint('Tested', case, 'case with', err, 'errors')\\n\\ndef GI(V, E, ls=None, Directed=False, index=1):\\n\\torg_inp = []\\n\\tg = [[] for i in range(V)]\\n\\tFromStdin = True if ls == None else False\\n\\tfor i in range(E):\\n\\t\\tif FromStdin:\\n\\t\\t\\tinp = LI()\\n\\t\\t\\torg_inp.append(inp)\\n\\t\\telse:\\n\\t\\t\\tinp = ls[i]\\n\\t\\tif len(inp) == 2:\\n\\t\\t\\t(a, b) = inp\\n\\t\\t\\tc = 1\\n\\t\\telse:\\n\\t\\t\\t(a, b, c) = inp\\n\\t\\tif index == 1:\\n\\t\\t\\ta -= 1\\n\\t\\t\\tb -= 1\\n\\t\\taa = (a, c)\\n\\t\\tbb = (b, c)\\n\\t\\tg[a].append(bb)\\n\\t\\tif not Directed:\\n\\t\\t\\tg[b].append(aa)\\n\\treturn (g, org_inp)\\n\\ndef GGI(h, w, search=None, replacement_of_found='.', mp_def={'#': 1, '.': 0}, boundary=1):\\n\\tmp = [boundary] * (w + 2)\\n\\tfound = {}\\n\\tfor i in R(h):\\n\\t\\ts = input()\\n\\t\\tfor char in search:\\n\\t\\t\\tif char in s:\\n\\t\\t\\t\\tfound[char] = (i + 1) * (w + 2) + s.index(char) + 1\\n\\t\\t\\t\\tmp_def[char] = mp_def[replacement_of_found]\\n\\t\\tmp += [boundary] + [mp_def[j] for j in s] + [boundary]\\n\\tmp += [boundary] * (w + 2)\\n\\treturn (h + 2, w + 2, mp, found)\\n\\ndef TI(n):\\n\\treturn GI(n, n - 1)\\n\\ndef accum(ls):\\n\\trt = [0]\\n\\tfor i in ls:\\n\\t\\trt += [rt[-1] + i]\\n\\treturn rt\\n\\ndef bit_combination(n, base=2):\\n\\trt = []\\n\\tfor tb in R(base ** n):\\n\\t\\ts = [tb // base ** bt % base for bt in R(n)]\\n\\t\\trt += [s]\\n\\treturn rt\\n\\ndef gcd(x, y):\\n\\tif y == 0:\\n\\t\\treturn x\\n\\tif x % y == 0:\\n\\t\\treturn y\\n\\twhile x % y != 0:\\n\\t\\t(x, y) = (y, x % y)\\n\\treturn y\\n\\ndef YN(x):\\n\\tprint(['NO', 'YES'][x])\\n\\ndef Yn(x):\\n\\tprint(['No', 'Yes'][x])\\n\\ndef show(*inp, end='\\\\n'):\\n\\tif show_flg:\\n\\t\\tprint(*inp, end=end)\\nmo = 10 ** 9 + 7\\ninf = float('inf')\\nFourNb = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\nEightNb = [(-1, 0), (1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\\ncompas = dict(zip('WENS', FourNb))\\ncursol = dict(zip('LRUD', FourNb))\\nl_alp = string.ascii_lowercase\\nread = sys.stdin.buffer.read\\nreadline = sys.stdin.buffer.readline\\ninput = lambda : sys.stdin.readline().rstrip()\\n\\nclass SegTree:\\n\\n\\tdef __init__(self, n, init_val=0, function=lambda a, b: a + b, ide=0):\\n\\t\\tself.size = n\\n\\t\\tself.ide_ele = ide\\n\\t\\tself.num = 1 << (self.size - 1).bit_length()\\n\\t\\tself.table = [self.ide_ele] * 2 * self.num\\n\\t\\tself.index = [0] * 2 * self.num\\n\\t\\tself.lazy = [self.ide_ele] * 2 * self.num\\n\\t\\tself.func = function\\n\\t\\tif not hasattr(init_val, '__iter__'):\\n\\t\\t\\tinit_val = [init_val] * self.size\\n\\t\\tfor (i, val) in enumerate(init_val):\\n\\t\\t\\tself.table[i + self.num - 1] = val\\n\\t\\t\\tself.index[i + self.num - 1] = i\\n\\t\\tfor i in range(self.num - 2, -1, -1):\\n\\t\\t\\tself.table[i] = self.func(self.table[2 * i + 1], self.table[2 * i + 2])\\n\\t\\t\\tif self.table[i] == self.table[i * 2 + 1]:\\n\\t\\t\\t\\tself.index[i] = self.index[i * 2 + 1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tself.index[i] = self.index[i * 2 + 2]\\n\\n\\tdef update(self, k, x):\\n\\t\\tk += self.num - 1\\n\\t\\tself.table[k] = x\\n\\t\\twhile k:\\n\\t\\t\\tk = (k - 1) // 2\\n\\t\\t\\tres = self.func(self.table[k * 2 + 1], self.table[k * 2 + 2])\\n\\t\\t\\tself.table[k] = res\\n\\t\\t\\tif res == self.table[k * 2 + 1]:\\n\\t\\t\\t\\tself.index[k] = self.index[k * 2 + 1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tself.index[k] = self.index[k * 2 + 2]\\n\\n\\tdef evaluate(k, l, r):\\n\\t\\tif lazy[k] != 0:\\n\\t\\t\\tnode[k] += lazy[k]\\n\\t\\t\\tif r - l > 1:\\n\\t\\t\\t\\tlazy[2 * k + 1] += lazy[k] // 2\\n\\t\\t\\t\\tlazy[2 * k + 2] += lazy[k] // 2\\n\\t\\tlazy[k] = 0\\n\\n\\tdef query(self, p, q):\\n\\t\\tif q <= p:\\n\\t\\t\\treturn self.ide_ele\\n\\t\\tp += self.num - 1\\n\\t\\tq += self.num - 2\\n\\t\\tres = self.ide_ele\\n\\t\\twhile q - p > 1:\\n\\t\\t\\tif p & 1 == 0:\\n\\t\\t\\t\\tres = self.func(res, self.table[p])\\n\\t\\t\\tif q & 1 == 1:\\n\\t\\t\\t\\tres = self.func(res, self.table[q])\\n\\t\\t\\t\\tq -= 1\\n\\t\\t\\tp = p >> 1\\n\\t\\t\\tq = q - 1 >> 1\\n\\t\\tif p == q:\\n\\t\\t\\tres = self.func(res, self.table[p])\\n\\t\\telse:\\n\\t\\t\\tres = self.func(self.func(res, self.table[p]), self.table[q])\\n\\t\\treturn res\\n\\n\\tdef query_id(self, p, q):\\n\\t\\tif q <= p:\\n\\t\\t\\treturn self.ide_ele\\n\\t\\tp += self.num - 1\\n\\t\\tq += self.num - 2\\n\\t\\tres = self.ide_ele\\n\\t\\tidx = p\\n\\t\\twhile q - p > 1:\\n\\t\\t\\tif p & 1 == 0:\\n\\t\\t\\t\\tres = self.func(res, self.table[p])\\n\\t\\t\\t\\tif res == self.table[p]:\\n\\t\\t\\t\\t\\tidx = self.index[p]\\n\\t\\t\\tif q & 1 == 1:\\n\\t\\t\\t\\tres = self.func(res, self.table[q])\\n\\t\\t\\t\\tif res == self.table[q]:\\n\\t\\t\\t\\t\\tidx = self.index[q]\\n\\t\\t\\t\\tq -= 1\\n\\t\\t\\tp = p >> 1\\n\\t\\t\\tq = q - 1 >> 1\\n\\t\\tif p == q:\\n\\t\\t\\tres = self.func(res, self.table[p])\\n\\t\\t\\tif res == self.table[p]:\\n\\t\\t\\t\\tidx = self.index[p]\\n\\t\\telse:\\n\\t\\t\\tres = self.func(self.func(res, self.table[p]), self.table[q])\\n\\t\\t\\tif res == self.table[p]:\\n\\t\\t\\t\\tidx = self.index[p]\\n\\t\\t\\telif res == self.table[q]:\\n\\t\\t\\t\\tidx = self.index[q]\\n\\t\\treturn idx\\n\\n\\tdef __str__(self):\\n\\t\\trt = self.table[self.num - 1:self.num - 1 + self.size]\\n\\t\\treturn str(rt)\\n\\nclass Comb:\\n\\n\\tdef __init__(self, n, mo=10 ** 9 + 7):\\n\\t\\tself.fac = [0] * (n + 1)\\n\\t\\tself.inv = [1] * (n + 1)\\n\\t\\tself.fac[0] = 1\\n\\t\\tself.fact(n)\\n\\t\\tfor i in range(1, n + 1):\\n\\t\\t\\tself.fac[i] = i * self.fac[i - 1] % mo\\n\\t\\t\\tself.inv[n] *= i\\n\\t\\t\\tself.inv[n] %= mo\\n\\t\\tself.inv[n] = pow(self.inv[n], mo - 2, mo)\\n\\t\\tfor i in range(1, n):\\n\\t\\t\\tself.inv[n - i] = self.inv[n - i + 1] * (n - i + 1) % mo\\n\\t\\treturn\\n\\n\\tdef fact(self, n):\\n\\t\\treturn self.fac[n]\\n\\n\\tdef invf(self, n):\\n\\t\\treturn self.inv[n]\\n\\n\\tdef comb(self, x, y):\\n\\t\\tif y < 0 or y > x:\\n\\t\\t\\treturn 0\\n\\t\\treturn self.fac[x] * self.inv[x - y] * self.inv[y] % mo\\n\\nclass UnionFind:\\n\\n\\tdef __init__(self, n):\\n\\t\\tself.table = [-1] * n\\n\\n\\tdef _root(self, x):\\n\\t\\tif self.table[x] < 0:\\n\\t\\t\\treturn x\\n\\t\\telse:\\n\\t\\t\\tself.table[x] = self._root(self.table[x])\\n\\t\\t\\treturn self.table[x]\\n\\n\\tdef find(self, x, y):\\n\\t\\treturn self._root(x) == self._root(y)\\n\\n\\tdef union(self, x, y):\\n\\t\\tr1 = self._root(x)\\n\\t\\tr2 = self._root(y)\\n\\t\\tif r1 == r2:\\n\\t\\t\\treturn\\n\\t\\td1 = self.table[r1]\\n\\t\\td2 = self.table[r2]\\n\\t\\tif d1 <= d2:\\n\\t\\t\\tself.table[r2] = r1\\n\\t\\t\\tif d1 == d2:\\n\\t\\t\\t\\tself.table[r1] -= 1\\n\\t\\telse:\\n\\t\\t\\tself.table[r1] = r2\\n\\n\\tdef __str__(self):\\n\\t\\trt = [i if j < 0 else j for (i, j) in enumerate(self.table)]\\n\\t\\treturn str(rt)\\nshow_flg = False\\nshow_flg = True\\nans = 0\\ns = [int(i) for i in input()][::-1]\\nn = len(s)\\ncm = Comb(n + 10)\\nR = 0\\nL = n * (n - 1) // 2 % mo\\nD = 1\\nm = n - 1\\nd = 1\\nfor i in range(n):\\n\\tc = s[i]\\n\\tans += c * (R + L * D)\\n\\tR += D * d\\n\\td += 1\\n\\tL -= m\\n\\tm -= 1\\n\\tD *= 10\\n\\tD %= mo\\n\\tR %= mo\\n\\tL %= mo\\nprint(ans % mo)\\n\", \"import sys, os, io\\ns = input()\\nn = len(s)\\na = [0] * n\\nmod = 10 ** 9 + 7\\nfor i in range(n - 2, -1, -1):\\n\\ta[i] = a[i + 1] + (n - i - 1) * pow(10, n - i - 2, mod)\\n\\ta[i] %= mod\\nans = 0\\nfor i in range(n):\\n\\tval = int(s[i]) * pow(10, n - i - 1, mod)\\n\\ttimes = i * (i + 1) // 2\\n\\tans += val * times % mod\\n\\tans += int(s[i]) * a[i]\\n\\tans %= mod\\nprint(ans)\\n\", \"import sys\\nread = lambda : sys.stdin.readline().strip()\\nreadi = lambda : map(int, read().split())\\nfrom collections import *\\nnum = read()\\nn = len(num)\\ntotal = 0\\nmod = 10 ** 9 + 7\\nprefixSum = [0] * (n + 1)\\ntotal = 0\\nfor i in range(n):\\n\\tprefixSum[i + 1] = prefixSum[i] + int(num[i])\\nfor i in range(1, n + 1):\\n\\tprefixSum[i] *= n - i\\nfor i in range(2, n + 1):\\n\\ttotal = (total + (i - 1) * i // 2 % mod * int(num[i - 1]) * pow(10, n - i, mod)) % mod\\n\\ttotal = (total + prefixSum[i - 1] * pow(10, n - i, mod) % mod) % mod\\nprint(total)\\n\", \"N = input()\\nn = len(N)\\nMOD = 1000000007\\npre = 0\\nwei = 1\\nsuf = 1\\nans = 0\\nlst = int(N[-1])\\nlst_n = int(N[-1])\\nfor (i, a) in enumerate(N[-2::-1], 2):\\n\\twei = wei * 10 % MOD\\n\\ta = int(a)\\n\\tpre = (suf * a % MOD + ans) % MOD\\n\\tans = (pre + lst) % MOD\\n\\tlst_n = (a * wei + lst_n) % MOD\\n\\tlst = (lst + lst_n) % MOD\\n\\tsuf = (suf + i * wei % MOD) % MOD\\nprint(ans)\\n\", \"num = input()\\nn = len(num)\\nans = 0\\nmod = 1000000007\\ntis = [0] * n\\nsim = int(num[0])\\nans = 0\\nfor i in range(1, n):\\n\\ttis[i] = ((n - i) * sim + i * (i + 1) // 2 * int(num[i])) % mod\\n\\tsim = (sim + int(num[i])) % mod\\nten = [1]\\nfor _ in range(n):\\n\\tten.append(ten[-1] * 10 % mod)\\nfor i in range(n):\\n\\tans = (ans + tis[n - 1 - i] * ten[i]) % mod\\nprint(ans)\\n\", \"s = [int(c) for c in input()][::-1]\\nn = len(s)\\nmod = 1000000007\\n\\ndef inv(x):\\n\\treturn pow(x, mod - 2, mod)\\nteninv = inv(10)\\nP = [0]\\np = 1\\nfor x in s:\\n\\tP.append((P[-1] + x * p) % mod)\\n\\tp = p * 10 % mod\\nQ = [0]\\nfor i in range(n + 1):\\n\\tQ.append((Q[-1] + P[i] * pow(teninv, i, mod)) % mod)\\ns = 0\\nfor l in range(n):\\n\\tfirst = P[l] - P[0]\\n\\ts += (n - l) * first % mod\\n\\ts += P[n] * inv(9) % mod * (1 - inv(pow(10, n - l, mod))) % mod\\n\\td = Q[n + 1] - Q[l + 1]\\n\\ts = (s - d * inv(pow(teninv, l, mod)) % mod) % mod\\nprint(s % mod)\\n\", \"import os\\nimport sys\\nimport math\\nfrom io import BytesIO, IOBase\\nfrom fractions import Fraction\\nimport collections\\nfrom itertools import permutations\\nfrom collections import defaultdict\\nfrom collections import deque\\nimport threading\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\n\\nclass Factorial:\\n\\n\\tdef __init__(self, MOD):\\n\\t\\tself.MOD = MOD\\n\\t\\tself.factorials = [1, 1]\\n\\t\\tself.invModulos = [0, 1]\\n\\t\\tself.invFactorial_ = [1, 1]\\n\\n\\tdef calc(self, n):\\n\\t\\tif n <= -1:\\n\\t\\t\\tprint('Invalid argument to calculate n!')\\n\\t\\t\\tprint('n must be non-negative value. But the argument was ' + str(n))\\n\\t\\t\\texit()\\n\\t\\tif n < len(self.factorials):\\n\\t\\t\\treturn self.factorials[n]\\n\\t\\tnextArr = [0] * (n + 1 - len(self.factorials))\\n\\t\\tinitialI = len(self.factorials)\\n\\t\\tprev = self.factorials[-1]\\n\\t\\tm = self.MOD\\n\\t\\tfor i in range(initialI, n + 1):\\n\\t\\t\\tprev = nextArr[i - initialI] = prev * i % m\\n\\t\\tself.factorials += nextArr\\n\\t\\treturn self.factorials[n]\\n\\n\\tdef inv(self, n):\\n\\t\\tif n <= -1:\\n\\t\\t\\tprint('Invalid argument to calculate n^(-1)')\\n\\t\\t\\tprint('n must be non-negative value. But the argument was ' + str(n))\\n\\t\\t\\texit()\\n\\t\\tp = self.MOD\\n\\t\\tpi = n % p\\n\\t\\tif pi < len(self.invModulos):\\n\\t\\t\\treturn self.invModulos[pi]\\n\\t\\tnextArr = [0] * (n + 1 - len(self.invModulos))\\n\\t\\tinitialI = len(self.invModulos)\\n\\t\\tfor i in range(initialI, min(p, n + 1)):\\n\\t\\t\\tnext = -self.invModulos[p % i] * (p // i) % p\\n\\t\\t\\tself.invModulos.append(next)\\n\\t\\treturn self.invModulos[pi]\\n\\n\\tdef invFactorial(self, n):\\n\\t\\tif n <= -1:\\n\\t\\t\\tprint('Invalid argument to calculate (n^(-1))!')\\n\\t\\t\\tprint('n must be non-negative value. But the argument was ' + str(n))\\n\\t\\t\\texit()\\n\\t\\tif n < len(self.invFactorial_):\\n\\t\\t\\treturn self.invFactorial_[n]\\n\\t\\tself.inv(n)\\n\\t\\tnextArr = [0] * (n + 1 - len(self.invFactorial_))\\n\\t\\tinitialI = len(self.invFactorial_)\\n\\t\\tprev = self.invFactorial_[-1]\\n\\t\\tp = self.MOD\\n\\t\\tfor i in range(initialI, n + 1):\\n\\t\\t\\tprev = nextArr[i - initialI] = prev * self.invModulos[i % p] % p\\n\\t\\tself.invFactorial_ += nextArr\\n\\t\\treturn self.invFactorial_[n]\\n\\nclass Combination:\\n\\n\\tdef __init__(self, MOD):\\n\\t\\tself.MOD = MOD\\n\\t\\tself.factorial = Factorial(MOD)\\n\\n\\tdef ncr(self, n, k):\\n\\t\\tif k < 0 or n < k:\\n\\t\\t\\treturn 0\\n\\t\\tk = min(k, n - k)\\n\\t\\tf = self.factorial\\n\\t\\treturn f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\\nmod = 10 ** 9 + 7\\nn = list(input())\\nk = 1\\nn = n[::-1]\\nl = len(n)\\nr = 0\\nc = 0\\nfor i in range(l):\\n\\td = c + (l - i) * (l - i - 1) // 2 * k\\n\\td %= mod\\n\\tc += k * (i + 1)\\n\\tc %= mod\\n\\tr += int(n[i]) * d\\n\\tr %= mod\\n\\tk *= 10\\n\\tk %= mod\\nr %= mod\\nprint(r)\\n\", \"MOD = 10 ** 9 + 7\\n\\ndef ahead(n, ab):\\n\\tif ab == 0:\\n\\t\\treturn 0\\n\\treturn ab * (ab + 1) // 2 * int(n[ab]) * pow(10, len(n) - ab - 1, MOD) % MOD\\nn = input()\\nans = 0\\ncurr = 0\\nfor ab in range(len(n) - 1, -1, -1):\\n\\tpl = len(n) - ab - 1\\n\\tah = ahead(n, ab)\\n\\tif pl != 0:\\n\\t\\tcurr += pl * pow(10, pl - 1, MOD) % MOD\\n\\tans += int(n[ab]) * curr\\n\\tans += ah\\n\\tans %= MOD\\nprint(ans % MOD)\\n\", \"import functools\\nMOD = 10 ** 9 + 7\\na = input()\\nm = len(a)\\ntotal = 0\\np = 1\\nfor i in range(m - 1, 0, -1):\\n\\td = int(a[i])\\n\\ttotal = (total % MOD + (i + 1) * i // 2 * d * p % MOD) % MOD\\n\\tp = 10 * p % MOD\\nx = 0\\np = 1\\nfor i in range(m - 2, -1, -1):\\n\\td = int(a[i])\\n\\ts = m - i - 1\\n\\tx = (x % MOD + p * s % MOD) % MOD\\n\\ttotal = (total % MOD + x * d % MOD) % MOD\\n\\tp = 10 * p % MOD\\nprint(total % MOD)\\n\", \"mo = 1000000007\\ns = input()\\nv = 0\\n(v1, s1) = (0, 0)\\n(v2, s2) = (0, 0)\\nfor i in range(len(s)):\\n\\tc = int(s[i])\\n\\tv2 = (v2 * 10 + v1 * 10 + (s2 + s1) * c) % mo\\n\\ts2 = s2 + s1\\n\\tv1 = (v1 + v) % mo\\n\\ts1 = s1 + 1\\n\\tv = (v * 10 + c) % mo\\nprint((v1 + v2) % mo)\\n\", \"import random\\nif 1:\\n\\ts = input()\\n\\tn = len(s)\\n\\ts = [s[n - i - 1] for i in range(n)]\\nelse:\\n\\tn = int(input())\\n\\ts = [random.randint(0, 9) for i in range(n)]\\nmod = 10 ** 9 + 7\\nans = 0\\nX = 0\\nS = 0\\nS2 = 0\\ninv = pow(2, mod - 2, mod)\\ninv_10 = pow(10, mod - 2, mod)\\nfor i in range(n):\\n\\ttmp = pow(10, i, mod) * ((n - i - 1) * (n - i) * inv) + S2 * pow(10, i + mod - 2, mod)\\n\\ttmp %= mod\\n\\ttmp *= int(s[i])\\n\\ttmp %= mod\\n\\tans += tmp\\n\\tans %= mod\\n\\tS += pow(inv_10, i, mod)\\n\\tS %= mod\\n\\tS2 += S\\n\\tS %= mod\\nprint(ans)\\n\", \"a = input()\\nn = len(a)\\nb = 0\\nc = 0\\nd = []\\ne = 1\\nfor i in range(n):\\n\\td.append(e)\\n\\te *= 10\\n\\te %= 10 ** 9 + 7\\nb = 0\\nfor i in range(n):\\n\\tb += int(a[i])\\nc = 0\\nfor i in range(n - 1, 0, -1):\\n\\tb -= int(a[i])\\n\\tc += (int(a[i]) * ((i + 1) * i // 2) + b * (n - i)) * d[n - 1 - i]\\n\\tc %= 10 ** 9 + 7\\nprint(c)\\n\", \"mod_n = 10 ** 9 + 7\\nremainders = dict()\\n\\ndef precalc_remainders(n):\\n\\tx = 1\\n\\tfor i in range(n + 1):\\n\\t\\tremainders[i] = x\\n\\t\\tx = x * 10 % mod_n\\n\\ndef get_remainder(digit, pos):\\n\\treturn remainders[pos] * digit % mod_n\\n\\ndef add_mod(result, value):\\n\\treturn (result + value) % mod_n\\n\\ndef sum_of_edits_old(num):\\n\\tn = len(num)\\n\\tresult = 0\\n\\tfor pos in range(n):\\n\\t\\tdigit = int(num[n - 1 - pos])\\n\\t\\tremainder = get_remainder(digit, pos)\\n\\t\\tresult = add_mod(result, remainder * (n - pos - 1) * (n - pos) // 2)\\n\\t\\tfor k in range(1, pos + 1):\\n\\t\\t\\tnew_remainder = get_remainder(digit, pos - k)\\n\\t\\t\\tresult = add_mod(result, new_remainder * (pos - k + 1))\\n\\treturn result\\n\\ndef sum_of_edits(num):\\n\\tn = len(num)\\n\\tresult = 0\\n\\taccumulated_counts = 0\\n\\tfor pos in range(n):\\n\\t\\tdigit = int(num[n - 1 - pos])\\n\\t\\tremainder = get_remainder(digit, pos)\\n\\t\\tresult = add_mod(result, remainder * (n - pos - 1) * (n - pos) // 2)\\n\\t\\tresult = add_mod(result, digit * accumulated_counts)\\n\\t\\taccumulated_counts = add_mod(accumulated_counts, remainders[pos] * (pos + 1))\\n\\treturn result\\nnum = input()\\nprecalc_remainders(len(num))\\nresult = sum_of_edits(num)\\nprint(result)\\n\", \"n = input()\\nmod = 1000000007\\nsz = 100001\\ntenMod = [0] * sz\\ntenMod[0] = 1\\nfor _ in range(1, sz):\\n\\ttenMod[_] = tenMod[_ - 1] * 10 % mod\\nprec = [0] * sz\\nprec[0] = 0\\nfor _ in range(1, sz):\\n\\tprec[_] = (prec[_ - 1] + _ * tenMod[_ - 1]) % mod\\nans = 0\\nfor _ in range(len(n)):\\n\\tans += (int(n[_]) * prec[len(n) - 1 - _] % mod + int(n[_]) * tenMod[len(n) - _ - 1] * ((_ + 1) * _ // 2) % mod % mod) % mod\\n\\tans %= mod\\nprint(ans)\\n\", \"import math\\nmod = int(1000000000.0 + 7)\\n\\ndef mul(a, b):\\n\\treturn a * b % mod\\n\\ndef addmod(a, b):\\n\\ta = a + b\\n\\tif a >= mod:\\n\\t\\ta -= mod\\n\\treturn a\\ns = input()\\nn = len(s)\\npow10 = [0] * (n + 1)\\npow10[0] = 1\\nfor i in range(1, n + 1):\\n\\tpow10[i] = mul(pow10[i - 1], 10)\\nright = [0] * (n + 1)\\nfor i in range(1, n + 1):\\n\\tright[i] = mul(i, pow10[i - 1])\\nfor i in range(1, n + 1):\\n\\tright[i] += right[i - 1]\\n\\tif right[i] >= mod:\\n\\t\\tright[i] -= mod\\nans = 0\\nfor i in range(n):\\n\\td = s[i]\\n\\td = int(d)\\n\\tans += mul(right[n - i - 1], d)\\n\\tans %= mod\\n\\tpref = i * (i + 1) // 2\\n\\tans += mul(d, mul(pref, pow10[n - i - 1]))\\n\\tans %= mod\\nprint(ans)\\n\", \"p = 10 ** 9 + 7\\nz = 0\\nv = 0\\ns = input()\\ns = s[::-1]\\nn = len(s)\\nfor (i, dx) in enumerate(s):\\n\\td = int(dx)\\n\\tz += pow(10, i, p) * d * (((n - i - 1) * (n - i - 2) // 2 + (n - i - 1)) % p)\\n\\tz %= p\\n\\tif i > 0:\\n\\t\\tv += i * pow(10, i - 1, p)\\n\\tv %= p\\n\\tz += d * v\\n\\tz %= p\\nprint(z)\\n\", \"s = input()\\nn = len(s)\\np = 10 ** 9 + 7\\ns += 'g'\\ns = s[::-1]\\nwyn = 0\\nacum = 0\\npot = [1] * (10 ** 5 + 5)\\nfor i in range(1, 10 ** 5 + 5):\\n\\tpot[i] = pot[i - 1] * 10 % p\\nfor i in range(1, n + 1):\\n\\tlic = int(s[i])\\n\\twyn += acum * lic\\n\\twyn += lic * pot[i - 1] * (n - i + 1) * (n - i) // 2\\n\\tacum += i * pot[i - 1]\\nprint(wyn % p)\\n\", \"MOD = 1000000007\\nn = input()\\n(pw, val) = ([1], [0])\\nfor i in range(1, 100100):\\n\\tval.append((val[i - 1] + i * pw[i - 1]) % MOD)\\n\\tpw.append(pw[i - 1] * 10 % MOD)\\n(res, pos) = (0, len(n))\\nfor i in n:\\n\\tres = res + val[pos - 1] * int(i)\\n\\tres %= MOD\\n\\trem = len(n) - pos\\n\\tres = res + int((rem * rem + rem) / 2) * pw[pos - 1] * int(i)\\n\\tres %= MOD\\n\\tpos -= 1\\nprint(res)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\ndef print(val):\\n\\tsys.stdout.write(str(val) + '\\\\n')\\n\\ndef prog():\\n\\tmod = 10 ** 9 + 7\\n\\tn = input().strip()[::-1]\\n\\tpsum1 = [0] * (10 ** 5 + 1)\\n\\tpsum2 = [0] * (10 ** 5 + 1)\\n\\tpsum11 = [0] * (10 ** 5 + 1)\\n\\tpsum22 = [0] * (10 ** 5 + 1)\\n\\ttens = [1] * (10 ** 5 + 1)\\n\\ttens_inv = [1] * (10 ** 5 + 1)\\n\\tfor i in range(1, len(n)):\\n\\t\\ttens[i] = tens[i - 1] * 10 % mod\\n\\ttens_inv[len(n) - 1] = pow(pow(10, len(n) - 1, mod), mod - 2, mod)\\n\\tfor i in range(len(n) - 2, -1, -1):\\n\\t\\ttens_inv[i] = tens_inv[i + 1] * 10 % mod\\n\\tfor i in range(len(n)):\\n\\t\\tpsum1[i + 1] = (psum1[i] + int(n[i]) * tens[i]) % mod\\n\\tfor i in range(len(n) - 1, -1, -1):\\n\\t\\tpsum2[i] = (psum2[i + 1] + int(n[i]) * tens[i]) % mod\\n\\tfor i in range(len(n)):\\n\\t\\tpsum11[i + 1] = (psum11[i] + psum1[i + 1]) % mod\\n\\tfor i in range(len(n) - 1, -1, -1):\\n\\t\\tpsum22[i] = (psum22[i + 1] + psum2[i]) % mod\\n\\tans = 0\\n\\tfor i in range(1, len(n)):\\n\\t\\tans = (ans + psum11[len(n) - i] + psum22[i] * tens_inv[i]) % mod\\n\\tprint((ans + mod) % mod)\\nprog()\\n\", \"import sys\\n\\ndef input():\\n\\treturn sys.stdin.readline().strip()\\n\\ndef list2d(a, b, c):\\n\\treturn [[c for j in range(b)] for i in range(a)]\\n\\ndef list3d(a, b, c, d):\\n\\treturn [[[d for k in range(c)] for j in range(b)] for i in range(a)]\\n\\ndef list4d(a, b, c, d, e):\\n\\treturn [[[[e for l in range(d)] for k in range(c)] for j in range(b)] for i in range(a)]\\n\\ndef ceil(x, y=1):\\n\\treturn int(-(-x // y))\\n\\ndef INT():\\n\\treturn int(input())\\n\\ndef MAP():\\n\\treturn map(int, input().split())\\n\\ndef LIST(N=None):\\n\\treturn list(MAP()) if N is None else [INT() for i in range(N)]\\n\\ndef Yes():\\n\\tprint('Yes')\\n\\ndef No():\\n\\tprint('No')\\n\\ndef YES():\\n\\tprint('YES')\\n\\ndef NO():\\n\\tprint('NO')\\nINF = 10 ** 19\\nMOD = 10 ** 9 + 7\\nEPS = 10 ** (-10)\\nS = input()\\nN = len(S)\\nsuf = [0] * (N + 1)\\nfor i in range(N - 1, -1, -1):\\n\\tsuf[i] = (suf[i + 1] + int(S[i]) * pow(10, N - i - 1, MOD)) % MOD\\nfor i in range(N - 1, -1, -1):\\n\\tsuf[i] += suf[i + 1]\\n\\tsuf[i] %= MOD\\npre = [0] * (N + 1)\\nfor i in range(N - 1):\\n\\tpre[i + 1] = (pre[i] * 10 + int(S[i])) % MOD\\nfor i in range(N):\\n\\tpre[i + 1] += pre[i]\\n\\tpre[i + 1] %= MOD\\nans = 0\\nfor i in range(N - 1, -1, -1):\\n\\tans += pre[i] * pow(10, N - i - 1, MOD) + suf[i + 1]\\n\\tans %= MOD\\nprint(ans)\\n\", \"d = input()\\n(n, MOD) = (len(d), 10 ** 9 + 7)\\n(sm, m) = (0, 1)\\nfor i in range(n - 1):\\n\\ttail = m * int(d[-i - 1]) % MOD\\n\\tm = m * 10 % MOD\\n\\tp = ((n - i - 1) * (n - i - 2) // 2 + n - i - 1) % MOD\\n\\tsm = (sm + tail * p) % MOD\\n(cc, m) = ([0] * n, 1)\\nfor i in range(n):\\n\\t(cc[i], m) = ((i + 1) * m % MOD, m * 10 % MOD)\\nfor i in range(1, n):\\n\\tcc[i] = (cc[i] + cc[i - 1]) % MOD\\nfor i in range(n - 1):\\n\\tsm = (sm + cc[-i - 2] * int(d[i])) % MOD\\nprint(sm)\\n\", \"MOD = 10 ** 9 + 7\\n\\ndef mul(x, y):\\n\\tglobal MOD\\n\\treturn x % MOD * (y % MOD) % MOD\\n\\ndef add(x, y):\\n\\tglobal MOD\\n\\treturn (x % MOD + y % MOD) % MOD\\n\\ndef testcase():\\n\\tn = input()\\n\\tdp = [0 for _ in n]\\n\\tdp[-1] = 0\\n\\ttemp = 1\\n\\tfor i in range(len(n) - 2, -1, -1):\\n\\t\\tdp[i] = add(dp[i + 1], mul(temp, len(n) - i - 1))\\n\\t\\ttemp = mul(temp, 10)\\n\\tans = 0\\n\\tfor i in range(len(n)):\\n\\t\\td = int(n[i])\\n\\t\\tr = mul(dp[i], d)\\n\\t\\tans = add(ans, r)\\n\\ttemp = 1\\n\\tfor i in range(len(n) - 1, 0, -1):\\n\\t\\td = int(n[i])\\n\\t\\tl = d\\n\\t\\tl = mul(d, mul(mul(i, i + 1), 500000004))\\n\\t\\tl = mul(l, temp)\\n\\t\\ttemp = mul(temp, 10)\\n\\t\\tans = add(ans, l)\\n\\tprint(ans)\\n\\treturn\\nt = 1\\nfor _ in range(t):\\n\\ttestcase()\\n\", \"import sys\\ninput = sys.stdin.buffer.readline\\na = list(input())\\nmod = 10 ** 9 + 7\\nwhile a[-1] <= 47:\\n\\ta.pop()\\nn = len(a)\\na.append(0)\\na = a[::-1]\\nres = 0\\nb = 0\\nten = 1\\nback = pow(810, mod - 2, mod)\\nfor j in range(1, n + 1):\\n\\tA = a[j] - 48\\n\\tif j != 1:\\n\\t\\ts = (9 * pow(10, j, mod) * j % mod - 10 * (pow(10, j, mod) - 1)) * back % mod\\n\\t\\tres = (res + A * s) % mod\\n\\tt = n - j\\n\\tif t == 0:\\n\\t\\tres = (res + A * pow(10, j - 1, mod)) % mod\\n\\telif t == 1:\\n\\t\\tres = (res + 2 * A * pow(10, j - 1, mod)) % mod\\n\\telse:\\n\\t\\tres = (res + A * (t + 1 + t * (t - 1) // 2) * pow(10, j - 1, mod)) % mod\\n\\tb = (b + A * ten) % mod\\n\\tten = ten * 10 % mod\\nres = (res - b) % mod\\nprint(res)\\n\", \"import sys\\nif not sys.warnoptions:\\n\\timport warnings\\n\\twarnings.simplefilter('ignore')\\n\\ndef ii():\\n\\treturn int(input())\\n\\ndef li():\\n\\treturn [int(i) for i in input().split()]\\n\\ndef ls():\\n\\treturn [i for i in input().split()]\\nMOD = 1000000007\\nn = input()\\np = []\\nsuff = [1]\\ntotal = 1\\nfor i in range(100001):\\n\\tp.append(total)\\n\\ttotal = total * 10 % MOD\\nfor i in range(1, 100001):\\n\\tx = ((i + 1) * p[i] + suff[i - 1]) % MOD\\n\\tsuff.append(x)\\nl = len(n)\\ntotal = 0\\nfor i in range(l):\\n\\tx = int(n[i])\\n\\tif l - i - 2 >= 0:\\n\\t\\ttotal = (total + i * (i + 1) // 2 * x * p[l - i - 1] + x * suff[l - i - 2]) % MOD\\n\\telse:\\n\\t\\ttotal = (total + i * (i + 1) // 2 * x * p[l - i - 1]) % MOD\\nprint(total)\\n\", \"s = input()\\nn = len(s)\\nmod = 1000000007\\nans = 0\\nfact = 1\\nleft = n * (n - 1) // 2 % mod\\nright = 0\\nfor i in range(n):\\n\\tans = (ans + right * int(s[n - 1 - i])) % mod\\n\\tans = (ans + left * fact * int(s[n - 1 - i])) % mod\\n\\tright = (right + (i + 1) * fact) % mod\\n\\tfact = fact * 10 % mod\\n\\tleft = (left - (n - 1 - i)) % mod\\nprint(ans)\\n\", \"n = list(map(int, input()))\\nmod = 10 ** 9 + 7\\nans = 0\\ntens = [1]\\nmults = [1]\\ncur = 0\\nprefix = []\\nsuffix = []\\nfor ch in n:\\n\\tcur = cur * 10 + ch\\n\\tcur %= mod\\n\\tprefix.append(cur)\\npow10 = 1\\ncur = 0\\nsuffix = []\\nfor ch in n[::-1]:\\n\\tcur = cur + ch * pow10\\n\\tcur %= mod\\n\\tpow10 *= 10\\n\\tpow10 %= mod\\n\\ttens.append(pow10)\\n\\tmults.append((pow10 + mults[-1]) % mod)\\n\\tsuffix.append(cur)\\nans = 0\\nfor i in range(len(n)):\\n\\tans += suffix[i] * (len(n) - i - 1)\\n\\tans %= mod\\nfor i in range(len(n) - 1):\\n\\tans += prefix[i] * mults[-3 - i]\\n\\tans %= mod\\nprint(ans % mod)\\n\", \"from sys import stdin, stdout\\nimport math\\nimport heapq\\nimport collections\\ninput = stdin.readline\\n\\ndef inputnum():\\n\\treturn int(input())\\n\\ndef inputnums():\\n\\treturn map(int, input().split())\\n\\ndef inputlist():\\n\\treturn list(map(int, input().split()))\\n\\ndef inputstring():\\n\\treturn [x for x in input()]\\n\\ndef inputstrings():\\n\\treturn [x for x in input().split()]\\n\\ndef inputstringnum():\\n\\treturn [ord(x) - ord('0') for x in input()]\\n\\ndef inputmatrixchar(rows):\\n\\tarr2d = [[j for j in input().strip()] for i in range(rows)]\\n\\treturn arr2d\\n\\ndef inputmatrixint(rows):\\n\\tarr2d = []\\n\\tfor _ in range(rows):\\n\\t\\tarr2d.append([int(i) for i in input().split()])\\n\\treturn arr2d\\ns = inputstringnum()\\nmod = 1000000007\\nn = len(s) - 1\\nans = 0\\nres = 0\\nsm = 0\\npw = 1\\nfor i in reversed(range(0, n)):\\n\\tres = (10 * res + sm) % mod\\n\\tans = (ans + (1 * i * (i + 1) // 2 % mod * pw + res) % mod * s[i]) % mod\\n\\tsm = (sm + pw) % mod\\n\\tpw = 10 * pw % mod\\nprint(ans)\\n\", \"s = input()\\nn = len(s)\\n(multi, curr) = (0, 0)\\nmod = 10 ** 9 + 7\\nfor (j, i) in enumerate(s[::-1]):\\n\\ta = int(i)\\n\\tcurr = (curr + (n - j) * (n - j - 1) // 2 * a * pow(10, j, mod) + multi * a) % mod\\n\\tmulti = (multi + pow(10, j, mod) * (j + 1)) % mod\\nprint(curr)\\n\", \"import sys\\nfrom sys import stdin\\nmod = 10 ** 9 + 7\\nn = stdin.readline()[:-1]\\nans = 0\\nns = 0\\nfor lp in range(len(n)):\\n\\tind = len(n) - 1 - lp\\n\\tpw = pow(10, lp, mod)\\n\\tans += ns * int(n[ind])\\n\\tans += int(n[ind]) * pw * ind * (ind + 1) // 2\\n\\tans %= mod\\n\\tns += (lp + 1) * pw\\n\\tns %= mod\\nprint(ans)\\n\", \"S = list(map(int, list(input())))\\nmod = 10 ** 9 + 7\\nn = len(S)\\n(ans, s, p) = (0, 0, 1)\\nfor i in reversed(range(n)):\\n\\tk = (i * (i + 1) // 2 * p + s) % mod\\n\\ts += p * (n - i)\\n\\tp = p * 10 % mod\\n\\tans += S[i] * k\\n\\tans %= mod\\nprint(ans)\\n\", \"import sys\\n\\ndef eprint(*args):\\n\\tprint(*args, file=sys.stderr)\\nzz = 1\\nif zz:\\n\\tinput = sys.stdin.readline\\nelse:\\n\\tsys.stdin = open('input.txt', 'r')\\n\\tsys.stdout = open('all.txt', 'w')\\ndi = [[-1, 0], [1, 0], [0, 1], [0, -1]]\\n\\ndef string(s):\\n\\treturn ''.join(s)\\n\\ndef fori(n):\\n\\treturn [fi() for i in range(n)]\\n\\ndef inc(d, c, x=1):\\n\\td[c] = d[c] + x if c in d else x\\n\\ndef bo(i):\\n\\treturn ord(i) - ord('A')\\n\\ndef li():\\n\\treturn [int(xx) for xx in input().split()]\\n\\ndef fli():\\n\\treturn [float(x) for x in input().split()]\\n\\ndef comp(a, b):\\n\\tif a > b:\\n\\t\\treturn 2\\n\\treturn 2 if a == b else 0\\n\\ndef gi():\\n\\treturn [xx for xx in input().split()]\\n\\ndef cil(n, m):\\n\\treturn n // m + int(n % m > 0)\\n\\ndef fi():\\n\\treturn int(input())\\n\\ndef pro(a):\\n\\treturn reduce(lambda a, b: a * b, a)\\n\\ndef swap(a, i, j):\\n\\t(a[i], a[j]) = (a[j], a[i])\\n\\ndef si():\\n\\treturn list(input().rstrip())\\n\\ndef mi():\\n\\treturn map(int, input().split())\\n\\ndef gh():\\n\\tsys.stdout.flush()\\n\\ndef isvalid(i, j):\\n\\treturn 0 <= i < n and 0 <= j < m and (a[i][j] != '.')\\n\\ndef bo(i):\\n\\treturn ord(i) - ord('a')\\n\\ndef graph(n, m):\\n\\tfor i in range(m):\\n\\t\\t(x, y) = mi()\\n\\t\\ta[x].append(y)\\n\\t\\ta[y].append(x)\\nt = 1\\nwhile t > 0:\\n\\tt -= 1\\n\\ts = si()\\n\\tn = len(s)\\n\\tfor i in range(len(s)):\\n\\t\\ts[i] = int(s[i])\\n\\td = [[0] * (n + 2) for i in range(10)]\\n\\tans = 0\\n\\tmod = 10 ** 9 + 7\\n\\tfor i in range(n):\\n\\t\\tans = (ans + (i * i + i) // 2 * s[i] * pow(10, n - i - 1, mod)) % mod\\n\\tfor i in range(n):\\n\\t\\td[s[i]][n - i - 1] += 1\\n\\tfor i in range(1, 10):\\n\\t\\tc = su = 0\\n\\t\\tfor j in range(n, -1, -1):\\n\\t\\t\\tans = (ans + pow(10, j, mod) * (c * (j + 1)) * i) % mod\\n\\t\\t\\tif d[i][j]:\\n\\t\\t\\t\\tc += 1\\n\\t\\t\\t\\tsu += j + 1\\n\\tprint(ans)\\n\", \"from itertools import accumulate\\n\\ndef power(a, b, mod):\\n\\tres = 1\\n\\twhile b:\\n\\t\\tif b % 2:\\n\\t\\t\\tres = res * a % mod\\n\\t\\tb //= 2\\n\\t\\ta = a * a % mod\\n\\treturn res % mod\\nnum = [int(i) for i in input().strip()]\\nn = len(num)\\nans = 0\\nMOD = 10 ** 9 + 7\\npf = list(accumulate(num))\\nfor i in range(n - 2, -1, -1):\\n\\tcurrent = power(10, i, MOD)\\n\\tquery = (pf[n - i - 2] * (i + 1) + num[n - i - 1] * ((n - i - 1) * (n - i) // 2)) % MOD\\n\\tcurrent = current * query % MOD\\n\\tans = (ans + current) % MOD\\nprint(ans)\\n\", \"n = input()[::-1]\\nmod = 10 ** 9 + 7\\nl = len(n)\\nout = 0\\nsp = 0\\nfor i in range(l):\\n\\tv = l - i - 1\\n\\tvv = v * (v + 1) // 2\\n\\ts = vv * pow(10, i, mod) % mod\\n\\tif i > 0:\\n\\t\\tsp += i * pow(10, i - 1, mod) % mod\\n\\ts = int(n[i]) * (s + sp)\\n\\tout += s % mod\\n\\tout %= mod\\nprint(out)\\n\", \"s = str(input())\\nc = len(s)\\nk = c\\nans = 0\\nm = 10 ** 9 + 7\\nl = [1] * (c + 1)\\nkkk = 1\\nfor i in range(1, c + 1):\\n\\tl[i] = (kkk * 10 * (i + 1) + l[i - 1]) % m\\n\\tkkk = kkk * 10 % m\\nfor i in range(c):\\n\\tif s[i] == '0':\\n\\t\\tcontinue\\n\\ttt = int(s[i])\\n\\th = c - i - 1\\n\\tif h > 0:\\n\\t\\tans = (ans + l[h - 1] * tt) % m\\n\\tkk = i * (i + 1) // 2 * pow(10, h, m) * tt % m\\n\\tans = (ans + kk) % m\\nprint(ans)\\n\", \"import sys\\nimport math\\nimport collections\\nimport heapq\\nimport decimal\\ninput = sys.stdin.readline\\nmod = 1000000007\\ns = input()\\nn = len(s) - 1\\ns1 = 0\\np = 1\\ns2 = 0\\nfor i in range(n - 1, -1, -1):\\n\\ts1 = (s1 + int(s[i]) * (i * (i + 1) // 2 % mod * p % mod + s2) % mod) % mod\\n\\ts2 = (s2 + p * (n - i) % mod) % mod\\n\\tp = p * 10 % mod\\nprint(s1)\\n\", \"import sys\\nimport heapq\\nimport copy\\nimport math\\nimport decimal\\ninput = sys.stdin.readline\\n\\ndef binary_exponentiation(a, b):\\n\\tans = 1\\n\\twhile b != 0:\\n\\t\\tbit = b % 2\\n\\t\\tif bit == 1:\\n\\t\\t\\tans = ans * a\\n\\t\\ta = a * a\\n\\t\\tb = b // 2\\n\\treturn ans\\n\\ndef inp():\\n\\treturn int(input())\\n\\ndef inlt():\\n\\treturn list(map(int, input().split()))\\n\\ndef insr():\\n\\ts = input()\\n\\treturn list(s[:len(s) - 1])\\n\\ndef insr2():\\n\\ts = input()\\n\\ts = list(s[:len(s) - 1])\\n\\ts = [ord(s[i]) - ord('a') for i in range(len(s))]\\n\\treturn s\\n\\ndef invr():\\n\\treturn map(int, input().split())\\nans = 0\\n\\ndef pr_list(a):\\n\\tprint(*a, sep=' ')\\n\\ndef swap(a, b):\\n\\ttemp = a\\n\\ta = b\\n\\tb = temp\\n\\treturn [a, b]\\n\\ndef pri(a, b):\\n\\ts = '? ' + str(a) + ' ' + str(b)\\n\\tprint(s)\\n\\tsys.stdout.flush()\\nresult = []\\n\\ndef nCk(arr, itr, k, n):\\n\\tif len(arr) == k:\\n\\t\\tresult.append(arr)\\n\\t\\treturn\\n\\tif len(arr) > k or itr == n + 1:\\n\\t\\treturn\\n\\tnCk(arr + [itr], itr + 1, k, n)\\n\\tnCk(arr, itr + 1, k, n)\\n\\treturn\\n\\ndef nPk(arr, itr, k, n):\\n\\tif len(arr) == k:\\n\\t\\tresult.append(arr)\\n\\t\\treturn\\n\\tif len(arr) > k or itr == n + 1:\\n\\t\\treturn\\n\\tfor i in range(len(arr) + 1):\\n\\t\\tnPk(arr[0:i] + [itr] + arr[i:len(arr)], itr + 1, k, n)\\n\\tnPk(arr, itr + 1, k, n)\\n\\treturn\\n\\ndef main():\\n\\ttests = 1\\n\\tmod = 1000000007\\n\\tlimit = 10 ** 18\\n\\tans = 0\\n\\tstack = []\\n\\tarr = []\\n\\theapq.heapify(arr)\\n\\tfor test in range(tests):\\n\\t\\ts = insr()\\n\\t\\tans = 0\\n\\t\\tn = len(s)\\n\\t\\tten = [1]\\n\\t\\tright = [0, 1]\\n\\t\\ttens = 10\\n\\t\\tfor i in range(n + 1):\\n\\t\\t\\tten.append(ten[-1] * 10 % mod)\\n\\t\\t\\tright.append((right[-1] + (i + 2) * tens) % mod)\\n\\t\\t\\ttens = tens * 10 % mod\\n\\t\\tfor i in range(n):\\n\\t\\t\\tleft = i\\n\\t\\t\\tr = n - 1 - i\\n\\t\\t\\tl = left * (left + 1) // 2 * ten[r] % mod\\n\\t\\t\\tans = (ans + int(s[i]) * (l + right[r])) % mod\\n\\t\\tprint(ans)\\nmain()\\n\", \"import io\\nimport os\\nfrom collections import Counter, defaultdict, deque\\n\\ndef solve(S):\\n\\tMOD = 10 ** 9 + 7\\n\\tA = [int(d) for d in S]\\n\\tN = len(A)\\n\\tpref = [0]\\n\\tfor x in A:\\n\\t\\tpref.append((pref[-1] * 10 + x) % MOD)\\n\\tprefpref = [0]\\n\\tfor x in pref:\\n\\t\\tprefpref.append((prefpref[-1] + x) % MOD)\\n\\tpows = [1]\\n\\tfor i in range(N + 1):\\n\\t\\tpows.append(pows[-1] * 10 % MOD)\\n\\ttotal = 0\\n\\tsuff = 0\\n\\tfor i in reversed(range(N)):\\n\\t\\tx = prefpref[i + 1] * pows[N - 1 - i] + (i + 1) * suff\\n\\t\\ttotal += x\\n\\t\\ttotal %= MOD\\n\\t\\tsuff = (A[i] * pows[N - 1 - i] + suff) % MOD\\n\\treturn total % MOD\\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\\nN = input().decode().strip()\\nans = solve(N)\\nprint(ans)\\n\", \"import os\\nimport sys\\nfrom io import BytesIO, IOBase\\n\\ndef main():\\n\\tn = input()\\n\\tMOD = 10 ** 9 + 7\\n\\tleftMultiplier = pow(10, len(n) - 1, MOD)\\n\\tinvTen = pow(10, MOD - 2, MOD)\\n\\tinvNine = pow(9, MOD - 2, MOD)\\n\\tans = 0\\n\\tfor i in range(len(n)):\\n\\t\\tk = int(n[i])\\n\\t\\tans += k * (i * (i + 1) // 2) * leftMultiplier\\n\\t\\tleftMultiplier *= invTen\\n\\t\\tans %= MOD\\n\\t\\tleftMultiplier %= MOD\\n\\trightMultiplier = 0\\n\\tfor i in range(len(n) - 1, -1, -1):\\n\\t\\tk = int(n[i])\\n\\t\\tans += k * rightMultiplier\\n\\t\\trightMultiplier *= 10\\n\\t\\trightMultiplier += (pow(10, len(n) - i, MOD) - 1) * invNine\\n\\t\\trightMultiplier %= MOD\\n\\t\\tans %= MOD\\n\\tprint(ans)\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nmain()\\n\", \"import sys, math\\nimport io, os\\nfrom bisect import bisect_left as bl, bisect_right as br, insort\\nfrom heapq import heapify, heappush, heappop\\nfrom collections import defaultdict as dd, deque, Counter\\n\\ndef data():\\n\\treturn sys.stdin.readline().strip()\\n\\ndef mdata():\\n\\treturn list(map(int, data().split()))\\n\\ndef outl(var):\\n\\tsys.stdout.write('\\\\n'.join(map(str, var)) + '\\\\n')\\n\\ndef out(var):\\n\\tsys.stdout.write(str(var) + '\\\\n')\\nINF = float('inf')\\nmod = 10 ** 9 + 7\\nn = data()\\nn1 = len(n)\\ns = [0]\\nt = 1\\nfor i in range(1, n1):\\n\\ts1 = (s[-1] + i * t) % mod\\n\\ts.append(s1)\\n\\tt = t * 10 % mod\\nans = 0\\nt = 1\\nfor i in range(n1 - 1, -1, -1):\\n\\tans = (ans + (s[n1 - i - 1] + (i + 1) * i * t // 2) * int(n[i])) % mod\\n\\tt = t * 10 % mod\\nout(ans)\\n\", \"import math, sys, bisect, heapq\\nfrom collections import defaultdict, Counter, deque\\nfrom itertools import groupby, accumulate\\nint1 = lambda x: int(x) - 1\\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\\nilele = lambda : map(int, input().split())\\nalele = lambda : list(map(int, input().split()))\\nilelec = lambda : map(int1, input().split())\\nalelec = lambda : list(map(int1, input().split()))\\n\\ndef list2d(a, b, c):\\n\\treturn [[c] * b for i in range(a)]\\n\\ndef list3d(a, b, c, d):\\n\\treturn [[[d] * c for j in range(b)] for i in range(a)]\\nMOD = 1000000000 + 7\\n\\ndef Y(c):\\n\\tprint(['NO', 'YES'][c])\\n\\ndef y(c):\\n\\tprint(['no', 'yes'][c])\\n\\ndef Yy(c):\\n\\tprint(['No', 'Yes'][c])\\nn = input()\\nm = len(n)\\npre = [0]\\nd = 1\\nres = 0\\nfor i in range(1, m + 2):\\n\\tres += d * i\\n\\tres %= MOD\\n\\td *= 10\\n\\td %= MOD\\n\\tpre.append(res)\\nans = 0\\nd = 1\\nfor i in range(m - 1, -1, -1):\\n\\tx = int(n[i])\\n\\tans += d * (i * (i + 1) // 2 % MOD) % MOD * x % MOD\\n\\tans %= MOD\\n\\tans += pre[m - i - 1] * x % MOD\\n\\tans %= MOD\\n\\td *= 10\\n\\td %= MOD\\nprint(ans)\\n\", \"u = list(map(int, list(input())))\\nq = 10 ** 9 + 7\\nn = len(u)\\npr = u[:]\\nfor i in range(n):\\n\\tpr[i] *= pow(10, n - i - 1, q)\\n\\tpr[i] %= q\\nfor i in range(n - 2, -1, -1):\\n\\tpr[i] += pr[i + 1]\\n\\tpr[i] %= q\\nprpr = pr[:]\\nfor i in range(n - 2, -1, -1):\\n\\tprpr[i] += prpr[i + 1]\\n\\tprpr[i] %= q\\nans = 0\\npw10 = [1] * (n + 1)\\nfor i in range(1, n + 1):\\n\\tpw10[i] = pw10[i - 1] * 10\\n\\tpw10[i] %= q\\nfor i in range(1, n + 1):\\n\\tpw10[i] += pw10[i - 1]\\n\\tpw10[i] %= q\\nfor i in range(1, n):\\n\\tcur = u[i - 1] * pw10[n - i - 1] % q\\n\\tans += prpr[i] + cur\\n\\tans %= q\\n\\tu[i] += u[i - 1] * 10\\n\\tu[i] %= q\\nprint(ans)\\n\", \"import sys\\nimport io, os\\nmod = 10 ** 9 + 7\\n\\ndef solve(s):\\n\\t(pref, suff) = ([0], [0])\\n\\tl = [int(i) for i in s if i != '\\\\n']\\n\\tfor i in range(len(l)):\\n\\t\\tpref.append((pref[-1] * 10 + l[i]) % mod)\\n\\tprefpref = [0]\\n\\tfor i in range(1, len(pref)):\\n\\t\\tprefpref.append((pref[i] + prefpref[-1]) % mod)\\n\\tpows = [1]\\n\\tfor i in range(len(l) + 1):\\n\\t\\tpows.append(pows[-1] * 10 % mod)\\n\\tfor i in range(len(l)):\\n\\t\\tsuff.append((suff[-1] + l[-i - 1] * pows[i]) % mod)\\n\\t(prefpref, suff) = (prefpref[:-1], suff[:-1])\\n\\tprefpref.reverse()\\n\\tans = 0\\n\\tn = len(l)\\n\\tfor i in range(n):\\n\\t\\tans += prefpref[i] * pows[i] + suff[i] * (n - i)\\n\\t\\tans %= mod\\n\\treturn ans % mod\\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\\nN = input().decode().strip()\\nans = solve(N)\\nprint(ans)\\n\", \"import sys\\nfrom functools import lru_cache, cmp_to_key\\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\\nfrom math import ceil, floor, gcd, fabs, factorial, fmod, sqrt, inf\\nfrom collections import defaultdict as dd, deque, Counter as C\\nfrom itertools import combinations as comb, permutations as perm\\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\\nfrom time import perf_counter\\nfrom fractions import Fraction\\nfrom decimal import Decimal\\nmod = pow(10, 9) + 7\\n\\ndef data():\\n\\treturn sys.stdin.readline().strip()\\n\\ndef out(var):\\n\\tsys.stdout.write(str(var) + '\\\\n')\\n\\ndef outa(*var, end='\\\\n'):\\n\\tsys.stdout.write(' '.join(map(str, var)) + end)\\n\\ndef l():\\n\\treturn list(sp())\\n\\ndef sl():\\n\\treturn list(ssp())\\n\\ndef sp():\\n\\treturn map(int, data().split())\\n\\ndef ssp():\\n\\treturn map(str, data().split())\\n\\ndef l1d(n, val=0):\\n\\treturn [val for i in range(n)]\\n\\ndef l2d(n, m, val=0):\\n\\treturn [l1d(n, val) for j in range(m)]\\n\\ndef natural(a):\\n\\treturn a * (a - 1) // 2\\nold = data()\\ns = list(map(int, old))\\ns = s[::-1]\\nn = len(s)\\nanswer = 0\\ntemp = 0\\nten = 1\\nfor i in range(n):\\n\\tanswer = (answer + s[i] * (natural(n - i) * ten + temp)) % mod\\n\\ttemp = (i + 1) * ten + temp\\n\\tten *= 10\\n\\ttemp %= mod\\n\\tten %= mod\\nout(answer)\\n\", \"import math\\nfirst = []\\nsecond = []\\nnumber = input()\\ncurr = 0\\ncounter = 1\\ntemp = []\\nfor i in range(len(number)):\\n\\tcurr += int(number[len(number) - i - 1]) * counter\\n\\tif len(temp) > 0:\\n\\t\\ttemp.append(curr + temp[-1])\\n\\telse:\\n\\t\\ttemp.append(curr)\\n\\tcounter = counter * 10 % 1000000007\\nfor i in range(len(temp)):\\n\\tsecond.append(temp[len(temp) - i - 1])\\nsecond.append(0)\\ncurr = 0\\nfor i in range(len(number)):\\n\\tcalculate = curr * (pow(10, len(number) - i, 1000000007 * 9) - 1) // 9\\n\\tfirst.append(calculate)\\n\\tcurr = (curr * 10 + int(number[i])) % (1000000007 * 9)\\ntotal = 0\\nfor i in range(len(number)):\\n\\ttotal += first[i]\\n\\ttotal += second[i + 1]\\nprint(int(total) % 1000000007)\\n\", \"a = input()\\ntotal = 0\\npri = pow(10, 9) + 7\\nt1 = 0\\nans = [1]\\nfor i in range(len(a) + 2):\\n\\tans.append(10 * ans[-1])\\n\\tans[-1] %= pri\\nt1 = 0\\nfor i in range(len(a) - 1):\\n\\tt1 += ans[i] * (i + 1)\\n\\tt1 %= pri\\nfor i in range(len(a)):\\n\\tm = ans[len(a) - i - 1] * (i * (i + 1) // 2) * int(a[i])\\n\\tm %= pri\\n\\ttotal += m\\n\\ttotal += int(a[i]) * t1 % pri\\n\\ttotal %= pri\\n\\tt1 -= (len(a) - i - 1) * ans[len(a) - i - 2]\\n\\tt1 %= pri\\ntotal %= pri\\nprint(total)\\n\", \"import sys\\ninput = sys.stdin.readline\\nMOD = 10 ** 9 + 7\\ns = input().rstrip()\\nn = len(s)\\nans = 0\\nmod81 = pow(81, MOD - 2, MOD)\\nfor (i, ch) in enumerate(s):\\n\\tt = n - i - 1\\n\\tret = int(ch) * (9 * pow(10, t, MOD) * t - pow(10, t, MOD) + 1) * mod81\\n\\tif i > 0:\\n\\t\\tret += int(ch) * ((i + 1) * i // 2 * pow(10, t, MOD))\\n\\tans += ret\\n\\tans %= MOD\\nprint(ans)\\n\", \"import sys\\nz = sys.stdin.readline\\nM = 10 ** 9 + 7\\nn = [*map(int, z().strip())]\\nl = len(n)\\np = [0]\\nfor i in range(l):\\n\\tp.append(p[-1] + n[i])\\ns = 0\\nv = (l * l - l) // 2\\nd = 1\\nfor i in range(1, l):\\n\\tr = p[l - i] * i + v * n[l - i]\\n\\ts = (s + r * d) % M\\n\\td = d * 10 % M\\n\\tv -= l - i\\nprint(s)\\n\", \"from itertools import accumulate\\nimport sys as _sys\\n\\ndef main():\\n\\tt = 1\\n\\tfor i_t in range(t):\\n\\t\\ts_n = _read_line()\\n\\t\\tresult = find_cost_modification_variants_sum(s_n, base=10, mod=10 ** 9 + 7)\\n\\t\\tprint(result)\\n\\ndef _read_line():\\n\\tresult = _sys.stdin.readline()\\n\\tassert result[-1] == '\\\\n'\\n\\treturn result[:-1]\\n\\ndef _read_ints():\\n\\treturn map(int, _read_line().split())\\n\\ndef find_cost_modification_variants_sum(s_cost, base, mod):\\n\\tdigits_n = len(s_cost)\\n\\tresult = 0\\n\\tr = 0\\n\\tbase_pow_r_moded = base ** r % mod\\n\\tx_mod_base_pow_r_moded = int(s_cost[digits_n - 1 - r]) * base_pow_r_moded % mod\\n\\tget_variants_n_moded = lambda r: (digits_n - 1 - r if r != digits_n - 1 else 1) % mod\\n\\tvariants_n_moded = get_variants_n_moded(r)\\n\\twhile r < digits_n - 1:\\n\\t\\tresult += x_mod_base_pow_r_moded * variants_n_moded % mod\\n\\t\\tresult %= mod\\n\\t\\tr += 1\\n\\t\\tbase_pow_r_moded *= base % mod\\n\\t\\tbase_pow_r_moded %= mod\\n\\t\\tx_mod_base_pow_r_moded += int(s_cost[digits_n - 1 - r]) * base_pow_r_moded % mod\\n\\t\\tx_mod_base_pow_r_moded %= mod\\n\\t\\tvariants_n_moded = get_variants_n_moded(r)\\n\\tsum_base_pow_b_moded = [base ** 0 % mod]\\n\\twhile len(sum_base_pow_b_moded) < digits_n:\\n\\t\\tprev = sum_base_pow_b_moded[-1]\\n\\t\\tcurr = prev * base % mod\\n\\t\\tsum_base_pow_b_moded.append(curr)\\n\\tsum_base_pow_b_moded = list(accumulate(sum_base_pow_b_moded))\\n\\ta = digits_n - 1\\n\\tcurr_x_shifted_by_a_moded = int(s_cost[0]) % mod\\n\\twhile a > 0:\\n\\t\\tmax_b = a - 1\\n\\t\\tresult += curr_x_shifted_by_a_moded * sum_base_pow_b_moded[max_b] % mod\\n\\t\\tresult %= mod\\n\\t\\ta -= 1\\n\\t\\tcurr_x_shifted_by_a_moded *= base % mod\\n\\t\\tcurr_x_shifted_by_a_moded += int(s_cost[digits_n - 1 - a]) % mod\\n\\t\\tcurr_x_shifted_by_a_moded %= mod\\n\\treturn result\\nmain()\\n\", \"n = input()\\nx = len(n)\\ns = [int(n[0])]\\nfor i in range(1, x):\\n\\ts.append(s[-1] + int(n[i]))\\npows = {0: 1}\\nfor i in range(1, x + 1):\\n\\tpows[i] = pows[i - 1] * 10 % (10 ** 9 + 7)\\nS = 0\\nfor i in range(x - 1):\\n\\tS += (s[i] * (x - i - 1) + (i + 1) * (i + 2) // 2 * int(n[i + 1])) * pows[x - i - 2]\\n\\tS = S % (10 ** 9 + 7)\\nprint(S)\\n\", \"n = input()\\nMOD = 10 ** 9 + 7\\ntotal = 0\\n\\ndef add(num):\\n\\tglobal total\\n\\ttotal += num\\n\\ttotal %= MOD\\n\\ndef mult10(num):\\n\\treturn (num << 3) + (num << 1)\\nK = []\\nk = 1\\nfor i in range(1, len(n)):\\n\\tK.append(k)\\n\\tk = mult10(k) + 1\\n\\tk %= MOD\\nif len(n) > 1:\\n\\tk = 1\\n\\tl = 10\\n\\tleft = int(n[0])\\n\\tright = int(n[-1])\\n\\tfor i in range(1, len(n)):\\n\\t\\tadd((len(n) - i) * right)\\n\\t\\tadd(K[-i] * left)\\n\\t\\tright += l * int(n[-(i + 1)])\\n\\t\\tright %= MOD\\n\\t\\tleft = mult10(left) + int(n[i])\\n\\t\\tleft %= MOD\\n\\t\\tl = mult10(l)\\n\\t\\tl %= MOD\\n\\tprint(total)\\nelse:\\n\\tprint(0)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\ndef insr():\\n\\ts = input()\\n\\treturn list(s[:len(s) - 1])\\nppp = 10 ** 9 + 7\\nstring = insr()\\nn = len(string)\\na = [0] * n\\nb = [0] * n\\ne = [0] * n\\ne[0] = int(string[0])\\nfor i in range(1, n):\\n\\tc = int(string[i])\\n\\ta[i] = ((a[i - 1] + b[i - 1]) * 10 + c * (i * (i + 1)) // 2) % ppp\\n\\tb[i] = (b[i - 1] + e[i - 1]) % ppp\\n\\te[i] = (e[i - 1] * 10 + c) % ppp\\nprint((a[n - 1] + b[n - 1]) % ppp)\\n\", \"import os\\nimport sys\\nfrom io import BytesIO, IOBase\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\n\\ndef RL():\\n\\treturn map(int, sys.stdin.readline().rstrip().split())\\n\\ndef RLL():\\n\\treturn list(map(int, sys.stdin.readline().rstrip().split()))\\n\\ndef N():\\n\\treturn int(input())\\n\\ndef print_list(l):\\n\\tprint(' '.join(map(str, l)))\\ns = input()\\nn = len(s)\\nM = 1000000007\\ndic = [[0] * n for _ in range(10)]\\ndic2 = [[0] * n for _ in range(10)]\\nfor k in range(1, 10):\\n\\tdic[k][0] = k\\n\\tfor i in range(1, n):\\n\\t\\tdic[k][i] = dic[k][i - 1] * 10 % M\\n\\tfor i in range(n):\\n\\t\\tdic2[k][i] = dic[k][i] * (i + 1) % M\\n\\tfor i in range(1, n):\\n\\t\\tdic2[k][i] = (dic2[k][i - 1] + dic2[k][i]) % M\\n\\tdic2[k].append(0)\\nres = 0\\nfor i in range(n):\\n\\tif s[i] != '0':\\n\\t\\tk = int(s[i])\\n\\t\\tres += dic2[k][n - i - 2]\\n\\t\\tres += dic[k][n - i - 1] * ((i * (i + 1) >> 1) % M) % M\\n\\t\\tres %= M\\nprint(res)\\n\", \"s = list(map(int, input()))\\nn = len(s)\\nmod = 1000000007\\nleft = n * (n - 1) // 2 % mod\\nright = 0\\nout = 0\\nfact = 1\\nfor i in range(n):\\n\\tout = (out + right * s[n - i - 1]) % mod\\n\\tout = (out + left * fact * s[n - i - 1]) % mod\\n\\tright = (right + (i + 1) * fact) % mod\\n\\tleft = (left - (n - i - 1)) % mod\\n\\tfact = fact * 10 % mod\\nprint(out)\\n\", \"import sys\\n\\ndef input():\\n\\treturn sys.stdin.readline()[:-1]\\n\\ndef getInt():\\n\\treturn int(input())\\n\\ndef getIntIter():\\n\\treturn map(int, input().split())\\n\\ndef getIntList():\\n\\treturn list(getIntIter())\\n\\ndef flush():\\n\\tsys.stdout.flush()\\nmod = 10 ** 9 + 7\\npowTen = [1]\\nfor x in range(10 ** 5):\\n\\tpowTen.append(powTen[-1] * 10 % mod)\\npairs = []\\nfor x in range(10 ** 5):\\n\\tpairs.append(x * (x + 1) // 2)\\nmulti = [0]\\nfor x in range(1, 10 ** 5):\\n\\tmulti.append((x * powTen[x - 1] + multi[-1]) % mod)\\nnum = input()\\nl = len(num)\\nans = 0\\nfor x in range(len(num)):\\n\\tp = l - 1 - x\\n\\td = int(num[x])\\n\\tans += powTen[p] * d * pairs[x]\\n\\tans %= mod\\n\\tans += multi[p] * d\\nprint(ans)\\n\", \"import os\\nimport sys\\nfrom io import BytesIO, IOBase\\n\\ndef contSum(n, p):\\n\\ta = n * (n + 1) % p\\n\\ta = a * pow(2, p - 2, p) % p\\n\\treturn a\\n\\ndef main():\\n\\ts = input()\\n\\tdigits = list()\\n\\tn = len(s)\\n\\tfor i in range(n - 1, -1, -1):\\n\\t\\tdigits.append(int(s[i]))\\n\\tp = int(1000000000.0 + 7)\\n\\tC = [0] * n\\n\\tfor i in range(n):\\n\\t\\tC[i] = pow(10, i, p) * (i + 1) % p\\n\\tprefix = [0] * n\\n\\tprefix[0] = C[0]\\n\\tfor i in range(1, n):\\n\\t\\tprefix[i] = (prefix[i - 1] + C[i]) % p\\n\\tans = 0\\n\\tfor i in range(n):\\n\\t\\td = digits[i]\\n\\t\\tright = contSum(n - i - 1, p) * pow(10, i, p) % p\\n\\t\\tright = right * d % p\\n\\t\\tif i == 0:\\n\\t\\t\\tleft = 0\\n\\t\\telse:\\n\\t\\t\\tleft = prefix[i - 1] * d % p\\n\\t\\tcontribution = (right + left) % p\\n\\t\\tans = (ans + contribution) % p\\n\\tprint(ans)\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode()) if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\tif self.buffer.tell():\\n\\t\\t\\treturn self.buffer.read().decode('ascii')\\n\\t\\treturn os.read(self._fd, os.fstat(self._fd).st_size).decode('ascii')\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline().decode('ascii')\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\ndef print(*args, sep=' ', end='\\\\n', file=sys.stdout, flush=False):\\n\\tat_start = True\\n\\tfor x in args:\\n\\t\\tif not at_start:\\n\\t\\t\\tfile.write(sep)\\n\\t\\tfile.write(str(x))\\n\\t\\tat_start = False\\n\\tfile.write(end)\\n\\tif flush:\\n\\t\\tfile.flush()\\n(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nsys.setrecursionlimit(10000)\\nmain()\\n\", \"import sys\\nimport math\\nfrom collections import defaultdict, deque\\ninput = sys.stdin.readline\\n\\ndef inar():\\n\\treturn [int(el) for el in input().split()]\\n\\ndef main():\\n\\tnum = input().strip()\\n\\tn = len(num)\\n\\tmod = 10 ** 9 + 7\\n\\tprefix = [0]\\n\\tans = 0\\n\\tfor i in range(1, n + 1):\\n\\t\\tprefix.append((i * pow(10, i - 1, mod) + prefix[-1]) % mod)\\n\\tfor i in range(n):\\n\\t\\td = int(num[i])\\n\\t\\tans = (ans + i * (i + 1) // 2 * (d * pow(10, n - i - 1, mod)) % mod) % mod\\n\\t\\tans = (ans + d * prefix[n - i - 1] % mod) % mod\\n\\tprint(ans)\\nmain()\\n\", \"import os\\nimport sys\\nfrom io import BytesIO, IOBase\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nvals = [int(k) for k in input()]\\nmod = 10 ** 9 + 7\\nn = len(vals)\\ntemp = [1]\\nfor s in range(1, n):\\n\\ttemp.append(temp[-1] * 10 % mod)\\nsum1 = 0\\nfor s in range(n - 1, 0, -1):\\n\\tsum1 += s * temp[s - 1]\\n\\tsum1 = sum1 % mod\\nans = 0\\nsum2 = 0\\nt = 0\\nfor s in range(n):\\n\\tans += vals[s] * (sum1 + t * temp[n - 1 - s])\\n\\tif s < n - 1:\\n\\t\\tsum1 -= (n - 1 - s) * temp[n - 2 - s]\\n\\t\\tt += s + 1\\n\\t\\tt = t % mod\\n\\tans = ans % mod\\n\\tsum1 = sum1 % mod\\n\\tsum2 = sum2 % mod\\nprint(ans)\\n\", \"s = input()\\nn = len(s)\\nnumber = int(s)\\nnum = 0\\nnum2 = 0\\np = 1000000007\\nbase = 1\\nans = 0\\nbase2 = 0\\nnums = []\\nfor i in range(n):\\n\\tbase2 += base\\n\\tbase2 %= p\\n\\tnums.append(base2)\\n\\tnum2 += base * (ord(s[n - 1 - i]) - ord('0'))\\n\\tnum2 %= p\\n\\tbase *= 10\\n\\tbase %= p\\n\\tans += num2 * (n - 1 - i)\\n\\tans %= p\\nfor i in range(n - 1):\\n\\tnum *= 10\\n\\tnum += ord(s[i]) - ord('0')\\n\\tnum %= p\\n\\tans += num * nums[n - 2 - i]\\n\\tans %= p\\nprint(ans % p)\\n\", \"import os\\nimport sys\\nfrom io import BytesIO, IOBase\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nfrom math import gcd, ceil\\n\\ndef prod(a, mod=10 ** 9 + 7):\\n\\tans = 1\\n\\tfor each in a:\\n\\t\\tans = ans * each % mod\\n\\treturn ans\\n\\ndef lcm(a, b):\\n\\treturn a * b // gcd(a, b)\\n\\ndef binary(x, length=16):\\n\\ty = bin(x)[2:]\\n\\treturn y if len(y) >= length else '0' * (length - len(y)) + y\\nfor _ in range(int(input()) if not True else 1):\\n\\ts = [int(k) for k in input()]\\n\\tn = len(s)\\n\\tmod = 10 ** 9 + 7\\n\\ttenpow = [1] * (n + 696)\\n\\tfor i in range(1, n + 696):\\n\\t\\ttenpow[i] = tenpow[i - 1] * 10 % mod\\n\\ttsum = 0\\n\\ttsums = [0]\\n\\tfor i in range(n - 1):\\n\\t\\ttsum = (tsum + s[i]) % mod\\n\\t\\ttsums += [tsum]\\n\\tans = 0\\n\\tfor i in range(n - 1):\\n\\t\\tv = (n - 1 - i) * (n - i) // 2\\n\\t\\ttsum = tsums[n - 1 - i] * (i + 1)\\n\\t\\tans = (ans + tenpow[i] * (v * s[n - i - 1] + tsum)) % mod\\n\\tprint(ans % mod)\\n\", \"num = input()\\ns = len(num)\\ndp = [[0 for j in range(s + 1)] for i in range(10)]\\nmdp = [[0 for j in range(s + 1)] for i in range(10)]\\nmod = int(10 ** 9 + 7)\\nfor i in range(10):\\n\\tsu = 0\\n\\tfor j in range(s + 1):\\n\\t\\tif j == 0:\\n\\t\\t\\tdp[i][j] = 0\\n\\t\\t\\tmdp[i][j] = i\\n\\t\\telse:\\n\\t\\t\\tmdp[i][j] = mdp[i][j - 1] * 10 % mod\\n\\t\\t\\tsu = mdp[i][j - 1] * j\\n\\t\\t\\tdp[i][j] = (su + dp[i][j - 1]) % mod\\nres = 0\\nmdp2 = [1 for i in range(s + 1)]\\nfor i in range(1, s + 1):\\n\\tmdp2[i] = mdp2[i - 1] * 10 % mod\\nfor i in range(s):\\n\\tx = int(num[i])\\n\\tres += dp[x][s - i - 1]\\n\\tres += x * mdp2[s - i - 1] % mod * i * (i + 1) // 2\\n\\tres = res % mod\\nprint(res)\\n\", \"mod = 10 ** 9 + 7\\ns = list(map(int, list(input())))\\nn = len(s)\\nsumm = sum(s[0:n - 1])\\nnum = n * (n + 1) // 2\\nans = 0\\nfor i in range(1, n + 1):\\n\\tnum -= n - i + 1\\n\\tans += (i * summ + num * s[n - i]) * pow(10, i - 1, mod) % mod\\n\\tans = ans % mod\\n\\tsumm -= s[n - i - 1]\\nprint(ans)\\n\", \"from sys import stdin\\ns = stdin.readline().strip()\\nn = len(s)\\nif n == 1:\\n\\tprint(0)\\n\\texit(0)\\nmod = 10 ** 9 + 7\\npref = [0 for i in range(n)]\\napref = [0 for i in range(n)]\\nasuf = [0 for i in range(n)]\\nsuf = [0 for i in range(n)]\\npref[0] = int(s[0])\\napref[0] = int(s[0])\\nsuf[0] = int(s[-1])\\nasuf[0] = int(s[-1])\\nfor i in range(1, n):\\n\\tpref[i] = (pref[i - 1] * 10 + int(s[i])) % mod\\n\\tapref[i] = (apref[i - 1] + pref[i]) % mod\\naux = 10\\nx = 0\\nfor i in range(n - 2, -1, -1):\\n\\tsuf[x + 1] = (suf[x] + int(s[i]) * aux) % mod\\n\\tasuf[x + 1] = (asuf[x] + suf[x + 1]) % mod\\n\\tx += 1\\n\\taux = aux * 10 % mod\\nsuf = suf[::-1]\\nasuf = asuf[::-1]\\naux = 10\\nans = 0\\nfor i in range(n - 2, 0, -1):\\n\\tans = (ans + apref[i - 1] * aux + suf[i + 1] * i) % mod\\n\\taux = aux * 10 % mod\\nprint((ans + apref[n - 2] + asuf[1]) % mod)\\n\", \"m = 1000000007\\ns = str(input())\\nn = len(s)\\ndp = [0 for i in range(n)]\\ni = n - 2\\nb = int(s[-1])\\nc = b\\nwhile i > -1:\\n\\tk = n - i - 1\\n\\td = (k * pow(10, k + 1, m) - (k + 1) * pow(10, k, m) + 1) * pow(81, m - 2, m)\\n\\tdp[i] = (c + dp[i + 1] + int(s[i]) * d) % m\\n\\tb = (b + int(s[i]) * pow(10, k, m)) % m\\n\\tc = (c + b) % m\\n\\ti -= 1\\nprint(dp[0])\\n\", \"import math\\nimport random\\nimport heapq, bisect\\nimport sys\\nfrom collections import deque, defaultdict\\nfrom fractions import Fraction\\nimport sys\\nimport threading\\nfrom collections import defaultdict\\nmod = 10 ** 9 + 7\\nmod1 = 998244353\\nimport os\\nimport sys\\nfrom io import BytesIO, IOBase\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\n\\nclass TreeNode:\\n\\n\\tdef __init__(self, k, v):\\n\\t\\tself.key = k\\n\\t\\tself.value = v\\n\\t\\tself.left = None\\n\\t\\tself.right = None\\n\\t\\tself.parent = None\\n\\t\\tself.height = 1\\n\\t\\tself.num_left = 1\\n\\t\\tself.num_total = 1\\n\\nclass AvlTree:\\n\\n\\tdef __init__(self):\\n\\t\\tself._tree = None\\n\\n\\tdef add(self, k, v):\\n\\t\\tif not self._tree:\\n\\t\\t\\tself._tree = TreeNode(k, v)\\n\\t\\t\\treturn\\n\\t\\tnode = self._add(k, v)\\n\\t\\tif node:\\n\\t\\t\\tself._rebalance(node)\\n\\n\\tdef _add(self, k, v):\\n\\t\\tnode = self._tree\\n\\t\\twhile node:\\n\\t\\t\\tif k < node.key:\\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tnode = node.left\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnode.left = TreeNode(k, v)\\n\\t\\t\\t\\t\\tnode.left.parent = node\\n\\t\\t\\t\\t\\treturn node.left\\n\\t\\t\\telif node.key < k:\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tnode = node.right\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnode.right = TreeNode(k, v)\\n\\t\\t\\t\\t\\tnode.right.parent = node\\n\\t\\t\\t\\t\\treturn node.right\\n\\t\\t\\telse:\\n\\t\\t\\t\\tnode.value = v\\n\\t\\t\\t\\treturn\\n\\n\\t@staticmethod\\n\\tdef get_height(x):\\n\\t\\treturn x.height if x else 0\\n\\n\\t@staticmethod\\n\\tdef get_num_total(x):\\n\\t\\treturn x.num_total if x else 0\\n\\n\\tdef _rebalance(self, node):\\n\\t\\tn = node\\n\\t\\twhile n:\\n\\t\\t\\tlh = self.get_height(n.left)\\n\\t\\t\\trh = self.get_height(n.right)\\n\\t\\t\\tn.height = max(lh, rh) + 1\\n\\t\\t\\tbalance_factor = lh - rh\\n\\t\\t\\tn.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\\n\\t\\t\\tn.num_left = 1 + self.get_num_total(n.left)\\n\\t\\t\\tif balance_factor > 1:\\n\\t\\t\\t\\tif self.get_height(n.left.left) < self.get_height(n.left.right):\\n\\t\\t\\t\\t\\tself._rotate_left(n.left)\\n\\t\\t\\t\\tself._rotate_right(n)\\n\\t\\t\\telif balance_factor < -1:\\n\\t\\t\\t\\tif self.get_height(n.right.right) < self.get_height(n.right.left):\\n\\t\\t\\t\\t\\tself._rotate_right(n.right)\\n\\t\\t\\t\\tself._rotate_left(n)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tn = n.parent\\n\\n\\tdef _remove_one(self, node):\\n\\t\\treplacement = node.left or node.right\\n\\t\\tif node.parent:\\n\\t\\t\\tif AvlTree._is_left(node):\\n\\t\\t\\t\\tnode.parent.left = replacement\\n\\t\\t\\telse:\\n\\t\\t\\t\\tnode.parent.right = replacement\\n\\t\\t\\treplacement.parent = node.parent\\n\\t\\t\\tnode.parent = None\\n\\t\\telse:\\n\\t\\t\\tself._tree = replacement\\n\\t\\t\\treplacement.parent = None\\n\\t\\tnode.left = None\\n\\t\\tnode.right = None\\n\\t\\tnode.parent = None\\n\\t\\tself._rebalance(replacement)\\n\\n\\tdef _remove_leaf(self, node):\\n\\t\\tif node.parent:\\n\\t\\t\\tif AvlTree._is_left(node):\\n\\t\\t\\t\\tnode.parent.left = None\\n\\t\\t\\telse:\\n\\t\\t\\t\\tnode.parent.right = None\\n\\t\\t\\tself._rebalance(node.parent)\\n\\t\\telse:\\n\\t\\t\\tself._tree = None\\n\\t\\tnode.parent = None\\n\\t\\tnode.left = None\\n\\t\\tnode.right = None\\n\\n\\tdef remove(self, k):\\n\\t\\tnode = self._get_node(k)\\n\\t\\tif not node:\\n\\t\\t\\treturn\\n\\t\\tif AvlTree._is_leaf(node):\\n\\t\\t\\tself._remove_leaf(node)\\n\\t\\t\\treturn\\n\\t\\tif node.left and node.right:\\n\\t\\t\\tnxt = AvlTree._get_next(node)\\n\\t\\t\\tnode.key = nxt.key\\n\\t\\t\\tnode.value = nxt.value\\n\\t\\t\\tif self._is_leaf(nxt):\\n\\t\\t\\t\\tself._remove_leaf(nxt)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tself._remove_one(nxt)\\n\\t\\t\\tself._rebalance(node)\\n\\t\\telse:\\n\\t\\t\\tself._remove_one(node)\\n\\n\\tdef get(self, k):\\n\\t\\tnode = self._get_node(k)\\n\\t\\treturn node.value if node else -1\\n\\n\\tdef _get_node(self, k):\\n\\t\\tif not self._tree:\\n\\t\\t\\treturn None\\n\\t\\tnode = self._tree\\n\\t\\twhile node:\\n\\t\\t\\tif k < node.key:\\n\\t\\t\\t\\tnode = node.left\\n\\t\\t\\telif node.key < k:\\n\\t\\t\\t\\tnode = node.right\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn node\\n\\t\\treturn None\\n\\n\\tdef get_at(self, pos):\\n\\t\\tx = pos + 1\\n\\t\\tnode = self._tree\\n\\t\\twhile node:\\n\\t\\t\\tif x < node.num_left:\\n\\t\\t\\t\\tnode = node.left\\n\\t\\t\\telif node.num_left < x:\\n\\t\\t\\t\\tx -= node.num_left\\n\\t\\t\\t\\tnode = node.right\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn (node.key, node.value)\\n\\t\\traise IndexError('Out of ranges')\\n\\n\\t@staticmethod\\n\\tdef _is_left(node):\\n\\t\\treturn node.parent.left and node.parent.left == node\\n\\n\\t@staticmethod\\n\\tdef _is_leaf(node):\\n\\t\\treturn node.left is None and node.right is None\\n\\n\\tdef _rotate_right(self, node):\\n\\t\\tif not node.parent:\\n\\t\\t\\tself._tree = node.left\\n\\t\\t\\tnode.left.parent = None\\n\\t\\telif AvlTree._is_left(node):\\n\\t\\t\\tnode.parent.left = node.left\\n\\t\\t\\tnode.left.parent = node.parent\\n\\t\\telse:\\n\\t\\t\\tnode.parent.right = node.left\\n\\t\\t\\tnode.left.parent = node.parent\\n\\t\\tbk = node.left.right\\n\\t\\tnode.left.right = node\\n\\t\\tnode.parent = node.left\\n\\t\\tnode.left = bk\\n\\t\\tif bk:\\n\\t\\t\\tbk.parent = node\\n\\t\\tnode.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\\n\\t\\tnode.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\\n\\t\\tnode.num_left = 1 + self.get_num_total(node.left)\\n\\n\\tdef _rotate_left(self, node):\\n\\t\\tif not node.parent:\\n\\t\\t\\tself._tree = node.right\\n\\t\\t\\tnode.right.parent = None\\n\\t\\telif AvlTree._is_left(node):\\n\\t\\t\\tnode.parent.left = node.right\\n\\t\\t\\tnode.right.parent = node.parent\\n\\t\\telse:\\n\\t\\t\\tnode.parent.right = node.right\\n\\t\\t\\tnode.right.parent = node.parent\\n\\t\\tbk = node.right.left\\n\\t\\tnode.right.left = node\\n\\t\\tnode.parent = node.right\\n\\t\\tnode.right = bk\\n\\t\\tif bk:\\n\\t\\t\\tbk.parent = node\\n\\t\\tnode.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\\n\\t\\tnode.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\\n\\t\\tnode.num_left = 1 + self.get_num_total(node.left)\\n\\n\\t@staticmethod\\n\\tdef _get_next(node):\\n\\t\\tif not node.right:\\n\\t\\t\\treturn node.parent\\n\\t\\tn = node.right\\n\\t\\twhile n.left:\\n\\t\\t\\tn = n.left\\n\\t\\treturn n\\n\\nclass SegmentTree1:\\n\\n\\tdef __init__(self, data, default=300006, func=lambda a, b: min(a, b)):\\n\\t\\tself._default = default\\n\\t\\tself._func = func\\n\\t\\tself._len = len(data)\\n\\t\\tself._size = _size = 1 << (self._len - 1).bit_length()\\n\\t\\tself.data = [default] * (2 * _size)\\n\\t\\tself.data[_size:_size + self._len] = data\\n\\t\\tfor i in reversed(range(_size)):\\n\\t\\t\\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\\n\\n\\tdef __delitem__(self, idx):\\n\\t\\tself[idx] = self._default\\n\\n\\tdef __getitem__(self, idx):\\n\\t\\treturn self.data[idx + self._size]\\n\\n\\tdef __setitem__(self, idx, value):\\n\\t\\tidx += self._size\\n\\t\\tself.data[idx] = value\\n\\t\\tidx >>= 1\\n\\t\\twhile idx:\\n\\t\\t\\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\\n\\t\\t\\tidx >>= 1\\n\\n\\tdef __len__(self):\\n\\t\\treturn self._len\\n\\n\\tdef query(self, start, stop):\\n\\t\\tif start == stop:\\n\\t\\t\\treturn self.__getitem__(start)\\n\\t\\tstop += 1\\n\\t\\tstart += self._size\\n\\t\\tstop += self._size\\n\\t\\tres = self._default\\n\\t\\twhile start < stop:\\n\\t\\t\\tif start & 1:\\n\\t\\t\\t\\tres = self._func(res, self.data[start])\\n\\t\\t\\t\\tstart += 1\\n\\t\\t\\tif stop & 1:\\n\\t\\t\\t\\tstop -= 1\\n\\t\\t\\t\\tres = self._func(res, self.data[stop])\\n\\t\\t\\tstart >>= 1\\n\\t\\t\\tstop >>= 1\\n\\t\\treturn res\\n\\n\\tdef __repr__(self):\\n\\t\\treturn 'SegmentTree({0})'.format(self.data)\\n\\nclass SegmentTree:\\n\\n\\tdef __init__(self, data, default=0, func=lambda a, b: a + b):\\n\\t\\tself._default = default\\n\\t\\tself._func = func\\n\\t\\tself._len = len(data)\\n\\t\\tself._size = _size = 1 << (self._len - 1).bit_length()\\n\\t\\tself.data = [default] * (2 * _size)\\n\\t\\tself.data[_size:_size + self._len] = data\\n\\t\\tfor i in reversed(range(_size)):\\n\\t\\t\\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\\n\\n\\tdef __delitem__(self, idx):\\n\\t\\tself[idx] = self._default\\n\\n\\tdef __getitem__(self, idx):\\n\\t\\treturn self.data[idx + self._size]\\n\\n\\tdef __setitem__(self, idx, value):\\n\\t\\tidx += self._size\\n\\t\\tself.data[idx] = value\\n\\t\\tidx >>= 1\\n\\t\\twhile idx:\\n\\t\\t\\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\\n\\t\\t\\tidx >>= 1\\n\\n\\tdef __len__(self):\\n\\t\\treturn self._len\\n\\n\\tdef query(self, start, stop):\\n\\t\\tif start == stop:\\n\\t\\t\\treturn self.__getitem__(start)\\n\\t\\tstop += 1\\n\\t\\tstart += self._size\\n\\t\\tstop += self._size\\n\\t\\tres = self._default\\n\\t\\twhile start < stop:\\n\\t\\t\\tif start & 1:\\n\\t\\t\\t\\tres = self._func(res, self.data[start])\\n\\t\\t\\t\\tstart += 1\\n\\t\\t\\tif stop & 1:\\n\\t\\t\\t\\tstop -= 1\\n\\t\\t\\t\\tres = self._func(res, self.data[stop])\\n\\t\\t\\tstart >>= 1\\n\\t\\t\\tstop >>= 1\\n\\t\\treturn res\\n\\n\\tdef __repr__(self):\\n\\t\\treturn 'SegmentTree({0})'.format(self.data)\\n\\nclass Factorial:\\n\\n\\tdef __init__(self, MOD):\\n\\t\\tself.MOD = MOD\\n\\t\\tself.factorials = [1, 1]\\n\\t\\tself.invModulos = [0, 1]\\n\\t\\tself.invFactorial_ = [1, 1]\\n\\n\\tdef calc(self, n):\\n\\t\\tif n <= -1:\\n\\t\\t\\tprint('Invalid argument to calculate n!')\\n\\t\\t\\tprint('n must be non-negative value. But the argument was ' + str(n))\\n\\t\\t\\texit()\\n\\t\\tif n < len(self.factorials):\\n\\t\\t\\treturn self.factorials[n]\\n\\t\\tnextArr = [0] * (n + 1 - len(self.factorials))\\n\\t\\tinitialI = len(self.factorials)\\n\\t\\tprev = self.factorials[-1]\\n\\t\\tm = self.MOD\\n\\t\\tfor i in range(initialI, n + 1):\\n\\t\\t\\tprev = nextArr[i - initialI] = prev * i % m\\n\\t\\tself.factorials += nextArr\\n\\t\\treturn self.factorials[n]\\n\\n\\tdef inv(self, n):\\n\\t\\tif n <= -1:\\n\\t\\t\\tprint('Invalid argument to calculate n^(-1)')\\n\\t\\t\\tprint('n must be non-negative value. But the argument was ' + str(n))\\n\\t\\t\\texit()\\n\\t\\tp = self.MOD\\n\\t\\tpi = n % p\\n\\t\\tif pi < len(self.invModulos):\\n\\t\\t\\treturn self.invModulos[pi]\\n\\t\\tnextArr = [0] * (n + 1 - len(self.invModulos))\\n\\t\\tinitialI = len(self.invModulos)\\n\\t\\tfor i in range(initialI, min(p, n + 1)):\\n\\t\\t\\tnext = -self.invModulos[p % i] * (p // i) % p\\n\\t\\t\\tself.invModulos.append(next)\\n\\t\\treturn self.invModulos[pi]\\n\\n\\tdef invFactorial(self, n):\\n\\t\\tif n <= -1:\\n\\t\\t\\tprint('Invalid argument to calculate (n^(-1))!')\\n\\t\\t\\tprint('n must be non-negative value. But the argument was ' + str(n))\\n\\t\\t\\texit()\\n\\t\\tif n < len(self.invFactorial_):\\n\\t\\t\\treturn self.invFactorial_[n]\\n\\t\\tself.inv(n)\\n\\t\\tnextArr = [0] * (n + 1 - len(self.invFactorial_))\\n\\t\\tinitialI = len(self.invFactorial_)\\n\\t\\tprev = self.invFactorial_[-1]\\n\\t\\tp = self.MOD\\n\\t\\tfor i in range(initialI, n + 1):\\n\\t\\t\\tprev = nextArr[i - initialI] = prev * self.invModulos[i % p] % p\\n\\t\\tself.invFactorial_ += nextArr\\n\\t\\treturn self.invFactorial_[n]\\n\\nclass Combination:\\n\\n\\tdef __init__(self, MOD):\\n\\t\\tself.MOD = MOD\\n\\t\\tself.factorial = Factorial(MOD)\\n\\n\\tdef ncr(self, n, k):\\n\\t\\tif k < 0 or n < k:\\n\\t\\t\\treturn 0\\n\\t\\tk = min(k, n - k)\\n\\t\\tf = self.factorial\\n\\t\\treturn f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\\n\\ndef powm(a, n, m):\\n\\tif a == 1 or n == 0:\\n\\t\\treturn 1\\n\\tif n % 2 == 0:\\n\\t\\ts = powm(a, n // 2, m)\\n\\t\\treturn s * s % m\\n\\telse:\\n\\t\\treturn a * powm(a, n - 1, m) % m\\n\\ndef sort_list(list1, list2):\\n\\tzipped_pairs = zip(list2, list1)\\n\\tz = [x for (_, x) in sorted(zipped_pairs)]\\n\\treturn z\\n\\ndef product(l):\\n\\tpor = 1\\n\\tfor i in range(len(l)):\\n\\t\\tpor *= l[i]\\n\\treturn por\\n\\ndef binarySearchCount(arr, n, key):\\n\\tleft = 0\\n\\tright = n - 1\\n\\tcount = 0\\n\\twhile left <= right:\\n\\t\\tmid = int((right + left) / 2)\\n\\t\\tif arr[mid] <= key:\\n\\t\\t\\tcount = mid + 1\\n\\t\\t\\tleft = mid + 1\\n\\t\\telse:\\n\\t\\t\\tright = mid - 1\\n\\treturn count\\n\\ndef countdig(n):\\n\\tc = 0\\n\\twhile n > 0:\\n\\t\\tn //= 10\\n\\t\\tc += 1\\n\\treturn c\\n\\ndef binary(x, length):\\n\\ty = bin(x)[2:]\\n\\treturn y if len(y) >= length else '0' * (length - len(y)) + y\\n\\ndef countGreater(arr, n, k):\\n\\tl = 0\\n\\tr = n - 1\\n\\tleftGreater = n\\n\\twhile l <= r:\\n\\t\\tm = int(l + (r - l) / 2)\\n\\t\\tif arr[m] > k:\\n\\t\\t\\tleftGreater = m\\n\\t\\t\\tr = m - 1\\n\\t\\telse:\\n\\t\\t\\tl = m + 1\\n\\treturn n - leftGreater\\n\\nclass TrieNode:\\n\\n\\tdef __init__(self):\\n\\t\\tself.children = [None] * 26\\n\\t\\tself.isEndOfWord = False\\n\\nclass Trie:\\n\\n\\tdef __init__(self):\\n\\t\\tself.root = self.getNode()\\n\\n\\tdef getNode(self):\\n\\t\\treturn TrieNode()\\n\\n\\tdef _charToIndex(self, ch):\\n\\t\\treturn ord(ch) - ord('a')\\n\\n\\tdef insert(self, key):\\n\\t\\tpCrawl = self.root\\n\\t\\tlength = len(key)\\n\\t\\tfor level in range(length):\\n\\t\\t\\tindex = self._charToIndex(key[level])\\n\\t\\t\\tif not pCrawl.children[index]:\\n\\t\\t\\t\\tpCrawl.children[index] = self.getNode()\\n\\t\\t\\tpCrawl = pCrawl.children[index]\\n\\t\\tpCrawl.isEndOfWord = True\\n\\n\\tdef search(self, key):\\n\\t\\tpCrawl = self.root\\n\\t\\tlength = len(key)\\n\\t\\tfor level in range(length):\\n\\t\\t\\tindex = self._charToIndex(key[level])\\n\\t\\t\\tif not pCrawl.children[index]:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tpCrawl = pCrawl.children[index]\\n\\t\\treturn pCrawl != None and pCrawl.isEndOfWord\\n\\nclass Node:\\n\\n\\tdef __init__(self, data):\\n\\t\\tself.data = data\\n\\t\\tself.count = 0\\n\\t\\tself.left = None\\n\\t\\tself.right = None\\n\\nclass BinaryTrie:\\n\\n\\tdef __init__(self):\\n\\t\\tself.root = Node(0)\\n\\n\\tdef insert(self, pre_xor):\\n\\t\\tself.temp = self.root\\n\\t\\tfor i in range(31, -1, -1):\\n\\t\\t\\tval = pre_xor & 1 << i\\n\\t\\t\\tif val:\\n\\t\\t\\t\\tif not self.temp.right:\\n\\t\\t\\t\\t\\tself.temp.right = Node(0)\\n\\t\\t\\t\\tself.temp = self.temp.right\\n\\t\\t\\t\\tself.temp.count += 1\\n\\t\\t\\tif not val:\\n\\t\\t\\t\\tif not self.temp.left:\\n\\t\\t\\t\\t\\tself.temp.left = Node(0)\\n\\t\\t\\t\\tself.temp = self.temp.left\\n\\t\\t\\t\\tself.temp.count += 1\\n\\t\\tself.temp.data = pre_xor\\n\\n\\tdef query(self, xor):\\n\\t\\tself.temp = self.root\\n\\t\\tfor i in range(31, -1, -1):\\n\\t\\t\\tval = xor & 1 << i\\n\\t\\t\\tif not val:\\n\\t\\t\\t\\tif self.temp.left and self.temp.left.count > 0:\\n\\t\\t\\t\\t\\tself.temp = self.temp.left\\n\\t\\t\\t\\telif self.temp.right:\\n\\t\\t\\t\\t\\tself.temp = self.temp.right\\n\\t\\t\\telif self.temp.right and self.temp.right.count > 0:\\n\\t\\t\\t\\tself.temp = self.temp.right\\n\\t\\t\\telif self.temp.left:\\n\\t\\t\\t\\tself.temp = self.temp.left\\n\\t\\t\\tself.temp.count -= 1\\n\\t\\treturn xor ^ self.temp.data\\nn = input()\\nans = 0\\nsu = 0\\nfor i in range(len(n) - 1, -1, -1):\\n\\tif i != len(n) - 1:\\n\\t\\tsu += (len(n) - i - 1) * pow(10, len(n) - i - 2, mod)\\n\\tsu %= mod\\n\\tans += pow(10, len(n) - i - 1, mod) * (i * (i + 1) // 2) * int(n[i])\\n\\tans %= mod\\n\\tans += su * int(n[i])\\n\\tans %= mod\\nprint(ans % mod)\\n\", \"import os\\nimport sys\\nfrom io import BytesIO, IOBase\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\n\\ndef RL():\\n\\treturn map(int, sys.stdin.readline().rstrip().split())\\n\\ndef RLL():\\n\\treturn list(RL())\\n\\ndef N():\\n\\treturn int(input())\\n\\ndef comb(n, m):\\n\\treturn factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\\n\\ndef perm(n, m):\\n\\treturn factorial(n) // factorial(n - m) if n >= m else 0\\n\\ndef mdis(x1, y1, x2, y2):\\n\\treturn abs(x1 - x2) + abs(y1 - y2)\\n\\ndef toord(c):\\n\\treturn ord(c) - ord('a')\\n\\ndef lcm(a, b):\\n\\treturn a * b // gcd(a, b)\\nmod = 10 ** 9 + 7\\nINF = float('inf')\\nfrom math import factorial, sqrt, ceil, floor, gcd\\nfrom collections import Counter, defaultdict, deque\\nfrom heapq import heapify, heappop, heappush\\n\\ndef main():\\n\\tn = input()\\n\\ttotal = 0\\n\\tle = len(n)\\n\\tfor i in range(1, le + 1):\\n\\t\\ttotal = total + i % mod\\n\\tres = 0\\n\\tsm = 0\\n\\trec = [0]\\n\\tfor i in range(le):\\n\\t\\trec.append((pow(10, i, mod) * (i + 1) + rec[-1]) % mod)\\n\\tfor i in range(le):\\n\\t\\tnow = int(n[i])\\n\\t\\t(left, right) = (i, le - i - 1)\\n\\t\\tres = res + sm * now * pow(10, right, mod) % mod\\n\\t\\tsm += i + 1\\n\\t\\tif now == 0:\\n\\t\\t\\tcontinue\\n\\t\\tres = res + now * rec[right]\\n\\tprint(res % mod)\\nmain()\\n\", \"import math\\nteststring = '100500100500\\\\n'\\nonline = __file__ != '/home/jhli/py/675/Problem_C.py'\\n(true, false) = (True, False)\\nif True:\\n\\n\\tdef spitout():\\n\\t\\tfor c in teststring.splitlines():\\n\\t\\t\\tyield c\\n\\t_ito = spitout()\\n\\tif not online:\\n\\n\\t\\tdef input():\\n\\t\\t\\treturn next(_ito)\\n\\n\\tdef build_enum(*a):\\n\\t\\tbuilt = dict()\\n\\t\\tfor (i, c) in enumerate(a):\\n\\t\\t\\tbuilt[c] = i\\n\\t\\treturn lambda x: built[x]\\ns = input()\\nl = len(s)\\nP = 10 ** 9 + 7\\n\\ndef egcd(a, b):\\n\\tif a == 0:\\n\\t\\treturn (b, 0, 1)\\n\\telse:\\n\\t\\t(g, y, x) = egcd(b % a, a)\\n\\t\\treturn (g, x - b // a * y, y)\\n\\ndef modinv(a):\\n\\t(g, x, y) = egcd(a, P)\\n\\tif g != 1:\\n\\t\\traise Exception('modular inverse does not exist')\\n\\telse:\\n\\t\\treturn x % P\\npowten = [1] * (l + 2)\\npre = [0] * (l + 2)\\nsuf = [0] * (l + 2)\\nfor i in range(1, l + 2):\\n\\tpowten[i] = powten[i - 1] * 10 % P\\nfor i in range(1, l):\\n\\tpre[i] = pre[i - 1] * 10 % P + int(s[i - 1])\\nfor i in range(l - 1, 0, -1):\\n\\tsuf[i - 1] = (suf[i] + int(s[i]) * powten[l - i - 1]) % P\\nans = 0\\nfor i in range(l):\\n\\tans = (ans + pre[i] * (powten[l - i] - 1) % P * modinv(9) % P) % P\\nfor j in range(l):\\n\\tans = (ans + (j + 1) * suf[j]) % P\\nprint(str(ans))\\n\", \"mod = int(1000000000.0 + 7)\\ns = input()\\nans = 0\\ncur = 0\\np = 1\\nm = 0\\nfor n in s[::-1]:\\n\\tm += 1\\n\\tn = int(n)\\n\\tans += n * cur\\n\\tans %= mod\\n\\tleft = len(s) - m\\n\\tans += n * p % mod * (1 + left) * left // 2\\n\\tans %= mod\\n\\tcur += m * p\\n\\tcur %= mod\\n\\tp *= 10\\n\\tp %= mod\\nprint(ans % mod)\\n\", \"def solve():\\n\\tn = input()\\n\\tn = n[::-1]\\n\\tMOD = 10 ** 9 + 7\\n\\tl = len(n)\\n\\tcnt = 0\\n\\tp = 1\\n\\tans = 0\\n\\tfor i in range(0, l):\\n\\t\\tm = l - i - 1\\n\\t\\tans += cnt * (ord(n[i]) - 48)\\n\\t\\tans %= MOD\\n\\t\\tans += p * (m * (m + 1)) // 2 * (ord(n[i]) - 48)\\n\\t\\tcnt = (i + 1) * p + cnt\\n\\t\\tp *= 10\\n\\t\\tcnt %= MOD\\n\\t\\tp %= MOD\\n\\tprint(ans)\\n\\treturn\\n\\ndef main():\\n\\tt = 1\\n\\tfor _ in range(t):\\n\\t\\tsolve()\\nmain()\\n\", \"n = input()\\ndp = [0] * (len(n) + 1)\\nmod = 10 ** 9 + 7\\nfor i in range(1, len(n) + 1):\\n\\tdp[i] = (dp[i - 1] + i * pow(10, i - 1, mod)) % mod\\nans = 0\\nfor i in range(len(n)):\\n\\tleft = i * (i + 1) // 2\\n\\tleft = left * int(n[i]) * pow(10, len(n) - i - 1, mod)\\n\\tright = int(n[i]) * dp[len(n) - i - 1] % mod\\n\\tans += (left + right) % mod\\nprint(ans % mod)\\n\", \"n = int(input())\\nA = list(str(n))\\nA.reverse()\\nA = [int(a) for a in A]\\nmod = 10 ** 9 + 7\\nm = len(A)\\ntemp = 0\\ncum = [0] * m\\nfor i in range(m):\\n\\ttemp += A[i] * pow(10, i, mod)\\n\\ttemp = temp % mod\\n\\tcum[i] = temp\\ncum = [0] + cum\\nmaxn = 10 ** 5 + 50\\nten = [0] * (maxn + 1)\\nten[0] = 1\\nfor i in range(1, maxn):\\n\\tten[i] = ten[i - 1] * 10\\n\\tten[i] %= mod\\ntable = [0] * (maxn + 1)\\ntable[0] = 1\\nfor i in range(1, maxn):\\n\\ttable[i] = table[i - 1] * 10 + 1\\n\\ttable[i] %= mod\\nres = 0\\ns = 0\\nfor l in range(m + 1):\\n\\tres += (cum[m] - cum[l]) * pow(ten[l], mod - 2, mod) * table[l - 1] + s\\n\\tres %= mod\\n\\ts += cum[l]\\nres %= mod\\nprint(res)\\n\", \"from bisect import *\\nfrom collections import *\\nfrom random import *\\nfrom decimal import *\\nimport sys\\ninput = sys.stdin.readline\\n\\ndef inp():\\n\\treturn int(input())\\n\\ndef st():\\n\\treturn input().rstrip('\\\\n')\\n\\ndef lis():\\n\\treturn list(map(int, input().split()))\\n\\ndef ma():\\n\\treturn map(int, input().split())\\np = 10 ** 9 + 7\\ns = st()\\npre = [int(s[0])]\\nfor i in range(1, len(s)):\\n\\tre = pre[-1] * 10\\n\\tre %= p\\n\\tre += int(s[i])\\n\\tre %= p\\n\\tpre.append(re)\\nsuf = [int(s[-1])]\\nfor i in range(len(s) - 1):\\n\\tre = int(s[len(s) - i - 2]) * int(pow(10, i + 1, p))\\n\\tre %= p\\n\\tre += suf[-1]\\n\\tre %= p\\n\\tsuf.append(re)\\nsufarr = [suf[0]]\\nfor i in range(1, len(s)):\\n\\tsufarr.append((sufarr[-1] + suf[i]) % p)\\npre.pop()\\nsuf.pop()\\nsufarr.pop()\\nn = len(pre)\\ninv = int(pow(9, p - 2, p))\\nres = sum(pre)\\nres %= p\\nres += sum(suf)\\nres %= p\\nfor i in range(n - 1):\\n\\tgp = 10\\n\\tre = pow(10, n - i - 1, p) - 1\\n\\tgp = gp * re % p\\n\\tgp = gp * inv\\n\\tgp = gp % p\\n\\tff = pre[i] * gp % p\\n\\tff += sufarr[n - i - 2]\\n\\tres += ff\\n\\tres %= p\\nprint(res)\\n\", \"import os\\nfrom io import BytesIO, IOBase\\nimport sys\\nfrom collections import defaultdict, deque, Counter\\nfrom bisect import *\\nfrom math import sqrt, pi\\nimport math\\nfrom itertools import permutations\\nfrom copy import deepcopy\\n\\ndef main():\\n\\ta = list(map(int, input().strip()))\\n\\tn = len(a)\\n\\tmod = 1000000007\\n\\td = [a[-1]]\\n\\te = [1]\\n\\tfor i in range(1, n + 1):\\n\\t\\te.append(e[-1] * 10 % mod)\\n\\tfor i in range(n - 2, -1, -1):\\n\\t\\td.append((d[-1] + a[i] * e[n - i - 1] % mod) % mod)\\n\\tfor i in range(1, n):\\n\\t\\td[i] = (d[i] + d[i - 1]) % mod\\n\\tans = 0\\n\\ts = 0\\n\\txx = pow(9, mod - 2, mod)\\n\\tfor i in range(n):\\n\\t\\tif i + 2 <= n:\\n\\t\\t\\tz = s * ((e[n - i] - 1) * xx) % mod\\n\\t\\t\\tans = (ans + d[-(i + 2)] + z) % mod\\n\\t\\telse:\\n\\t\\t\\tans = (ans + s) % mod\\n\\t\\ts = (s * 10 + a[i]) % mod\\n\\tprint(ans)\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nmain()\\n\", \"import sys, math\\ninput = sys.stdin.readline\\nmod = 10 ** 9 + 7\\ns = input().strip('\\\\n')\\nn = len(s)\\npow10 = [1]\\nfor i in range(1, n + 1):\\n\\tpow10.append(pow10[i - 1] * 10 % mod)\\nprefix = [1]\\nfor i in range(1, n):\\n\\tprefix.append((prefix[i - 1] + pow10[i] * (i + 1)) % mod)\\ns = s[::-1]\\nans = 0\\nfor i in range(n):\\n\\tif i > 0:\\n\\t\\tans += prefix[i - 1] * int(s[i])\\n\\t\\tans %= mod\\n\\tm = n - i\\n\\tans += int(s[i]) * (pow10[i] * (m * (m - 1) // 2))\\n\\tans %= mod\\nprint(ans)\\n\", \"mod = 10 ** 9 + 7\\nn = input().strip()\\ntens = []\\npre = [0]\\nfor i in range(10 ** 5 + 1):\\n\\ttens.append((i + 1) * pow(10, i, mod))\\n\\ttens[i] %= mod\\n\\tif i > 0:\\n\\t\\tpre.append(tens[i] + pre[-1])\\n\\telse:\\n\\t\\tpre.append(tens[i])\\n\\tpre[i] %= mod\\nf = len(n)\\nans = 0\\nfor i in range(f):\\n\\tans += i * (i + 1) // 2 * pow(10, f - i - 1, mod) * int(n[i])\\n\\tans %= mod\\n\\tans += int(n[i]) * pre[f - i - 1]\\n\\tans %= mod\\nprint(ans)\\n\", \"n = input()\\nm = 0\\nans = 0\\nb = 0\\nl = len(n)\\nM = int(1000000000.0 + 7)\\nB = [1] * l\\nfor i in range(1, l - 1):\\n\\tB[i] = B[i - 1] * 10 % M\\nfor i in range(1, l):\\n\\tm += i\\n\\tb += int(n[i - 1])\\n\\ta = l - i\\n\\tans += B[a - 1] * (a * b + m * int(n[i]))\\nprint(ans % M)\\n\", \"M = 10 ** 9 + 7\\ns = input()\\nn = len(s)\\na = [0] * n\\nval = [0] * (n + 1)\\nb = [0] * (n + 1)\\np = [0] * (n + 1)\\np[n - 1] = 1\\ncur = 1\\nfor i in range(n - 1, -1, -1):\\n\\tif i < n - 1:\\n\\t\\tp[i] = p[i + 1] * 10 % M\\n\\ta[i] = cur * int(s[i]) % M\\n\\tcur *= 10\\n\\tcur %= M\\n\\tval[i] = val[i + 1] + a[i]\\n\\tval[i] %= M\\nb[0] = int(s[0])\\nfor i in range(1, n):\\n\\tb[i] = (b[i - 1] * 10 + int(s[i])) % M\\nfor i in range(1, n):\\n\\tb[i] = (b[i - 1] + b[i]) % M\\nans = 0\\ncur = 0\\nfor i in range(1, n):\\n\\tl = i\\n\\tans = (ans + l * val[i] + b[i - 1] * p[i]) % M\\n\\ta[i] = (a[i - 1] + a[i]) % M\\nprint(ans)\\n\", \"mod = 10 ** 9 + 7\\npow10 = [1]\\nfor i in range(1, 200000):\\n\\tpow10 += [pow10[i - 1] * 10 % mod]\\ns = input()\\nn = len(s)\\nans = 0\\nleft = 0\\nright = 0\\nfor i in range(n - 1):\\n\\tright += pow10[i] * (i + 1)\\n\\tright %= mod\\nleftnum = 0\\nrightnum = n - 1\\nsub = n - 1\\nfor i in range(n):\\n\\tnum = int(s[i])\\n\\tans += num * right + num * left\\n\\trightnum -= 1\\n\\tleftnum += 1\\n\\tright -= sub * pow10[sub - 1]\\n\\tleft = leftnum * (leftnum + 1) // 2 * pow10[sub - 1]\\n\\tright %= mod\\n\\tleft %= mod\\n\\tans %= mod\\n\\tsub -= 1\\nprint(ans % mod)\\n\", \"from sys import stdin\\n\\nclass Input:\\n\\n\\tdef __init__(self):\\n\\t\\tself.it = iter(stdin.readlines())\\n\\n\\tdef line(self):\\n\\t\\treturn next(self.it).strip()\\n\\n\\tdef array(self, sep=' ', cast=int):\\n\\t\\treturn list(map(cast, self.line().split(sep=sep)))\\n\\ndef testcases(unknown=False):\\n\\tinpt = Input()\\n\\n\\tdef testcases_decorator(func):\\n\\t\\t(cases,) = [0] if unknown else inpt.array()\\n\\t\\twhile unknown or cases > 0:\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tfunc(inpt)\\n\\t\\t\\t\\tcases -= 1\\n\\t\\t\\texcept StopIteration:\\n\\t\\t\\t\\tbreak\\n\\treturn testcases_decorator\\nMOD = 1000000007\\nN = 100005\\nten = [1]\\nfor i in range(1, N):\\n\\tten.append(ten[-1] * 10)\\n\\tten[-1] %= MOD\\ns = [1]\\nfor i in range(1, N):\\n\\ts.append(ten[i] * (i + 1))\\n\\ts[-1] %= MOD\\nfor i in range(1, N):\\n\\ts[i] += s[i - 1]\\n\\ts[i] %= MOD\\n\\n@testcases(unknown=True)\\ndef solve(inpt):\\n\\tn = inpt.line()\\n\\tm = len(n)\\n\\tans = 0\\n\\tfor i in range(m):\\n\\t\\td = int(n[i])\\n\\t\\trg = m - 1 - i\\n\\t\\tif rg:\\n\\t\\t\\tans += d * s[rg - 1]\\n\\t\\tk = i * (i + 1) // 2\\n\\t\\tans += d * k * ten[m - 1 - i] % MOD\\n\\t\\tans %= MOD\\n\\tprint(ans)\\n\", \"from bisect import *\\nfrom collections import *\\nfrom math import *\\nfrom heapq import *\\nfrom typing import List\\nfrom itertools import *\\nfrom operator import *\\nfrom functools import *\\nimport sys\\nn = input()\\nl = len(n)\\nmod = 10 ** 9 + 7\\np10 = [1]\\ncof = [0]\\nfor i in range(1, l):\\n\\tp10.append(p10[-1] * 10 % mod)\\n\\tcof.append(cof[-1] + p10[i - 1] * i % mod)\\nans = 0\\nfor i in range(l):\\n\\tans = (ans + (cof[i] + (l - i) * (l - i - 1) // 2 * p10[i]) * int(n[l - 1 - i])) % mod\\nprint(ans)\\n\", \"mod = 10 ** 9 + 7\\ns = list(map(int, input()))[::-1]\\nn = len(s)\\nif n == 1:\\n\\tprint(0)\\n\\texit()\\npo = [1]\\nfor i in range(n):\\n\\tpo.append(po[-1] * 10 % mod)\\nsi = [0] * n\\nsi[n - 1] = s[n - 1]\\nfor i in range(n - 2, -1, -1):\\n\\tsi[i] = si[i + 1] + s[i]\\nans = 0\\nfor k in range(n - 1):\\n\\tans += (k + 1) * si[k + 1] * po[k]\\n\\tans %= mod\\nfor k in range(n - 1):\\n\\tans += s[k] * ((n - 1 - k) * (n - 1 - k - 1) // 2 + (n - 1 - k)) * po[k]\\n\\tans %= mod\\nprint(ans)\\n\", \"def read_int():\\n\\treturn int(input())\\nmod = 1000000007\\ns = input()\\nn = len(s)\\nten = [1]\\nf = [0]\\nfor i in range(n):\\n\\tten.append(ten[-1] * 10 % mod)\\n\\tf.append((f[-1] + (i + 1) * ten[i]) % mod)\\nans = 0\\nfor i in range(n):\\n\\tc = int(s[i])\\n\\tL = i\\n\\tR = n - i - 1\\n\\tlsub = L * (L + 1) // 2\\n\\tlsum = lsub * c * ten[R] % mod\\n\\trsum = f[R] * c % mod\\n\\tans = (ans + lsum + rsum) % mod\\nprint(ans)\\n\", \"import sys\\nimport os\\nfrom math import sqrt, log, log2, log10, gcd, floor, pow, sin, cos, tan, pi, inf, factorial\\nfrom copy import copy, deepcopy\\nfrom sys import exit, stdin, stdout\\nfrom collections import Counter, defaultdict, deque\\nfrom itertools import permutations\\nimport heapq\\nfrom bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nfrom bisect import bisect\\nmod = 1000000007\\niinp = lambda : int(sys.stdin.readline())\\ninp = lambda : sys.stdin.readline().strip()\\nstrl = lambda : list(inp().strip().split(' '))\\nintl = lambda : list(map(int, inp().split(' ')))\\nmint = lambda : map(int, inp().split())\\nflol = lambda : list(map(float, inp().split(' ')))\\nflush = lambda : stdout.flush()\\n\\ndef permute(nums):\\n\\n\\tdef fun(arr, nums, cur, v):\\n\\t\\tif len(cur) == len(nums):\\n\\t\\t\\tarr.append(cur.copy())\\n\\t\\ti = 0\\n\\t\\twhile i < len(nums):\\n\\t\\t\\tif v[i]:\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcur.append(nums[i])\\n\\t\\t\\t\\tv[i] = 1\\n\\t\\t\\t\\tfun(arr, nums, cur, v)\\n\\t\\t\\t\\tcur.pop()\\n\\t\\t\\t\\tv[i] = 0\\n\\t\\t\\t\\ti += 1\\n\\t\\treturn arr\\n\\tres = []\\n\\tnums.sort()\\n\\tv = [0] * len(nums)\\n\\treturn fun(res, nums, [], v)\\n\\ndef subsets(res, index, arr, cur):\\n\\tres.append(cur.copy())\\n\\tfor i in range(index, len(arr)):\\n\\t\\tcur.append(arr[i])\\n\\t\\tsubsets(res, i + 1, arr, cur)\\n\\t\\tcur.pop()\\n\\treturn res\\n\\ndef sieve(N):\\n\\troot = int(sqrt(N))\\n\\tprimes = [1] * (N + 1)\\n\\t(primes[0], primes[1]) = (0, 0)\\n\\tfor i in range(2, root + 1):\\n\\t\\tif primes[i]:\\n\\t\\t\\tfor j in range(i * i, N + 1, i):\\n\\t\\t\\t\\tprimes[j] = 0\\n\\treturn primes\\n\\ndef isPrime(n):\\n\\tif n <= 1:\\n\\t\\treturn False\\n\\tif n <= 3:\\n\\t\\treturn True\\n\\tif n % 2 == 0 or n % 3 == 0:\\n\\t\\treturn False\\n\\tp = int(sqrt(n))\\n\\tfor i in range(5, p + 1, 6):\\n\\t\\tif n % i == 0 or n % (i + 2) == 0:\\n\\t\\t\\treturn False\\n\\treturn True\\n\\ndef bs2(arr, l, r, x):\\n\\tif x < arr[0] or x > arr[len(arr) - 1]:\\n\\t\\treturn -1\\n\\twhile l <= r:\\n\\t\\tmid = l + (r - l) // 2\\n\\t\\tif arr[mid] == x:\\n\\t\\t\\treturn mid\\n\\t\\telif arr[mid] < x:\\n\\t\\t\\tl = mid + 1\\n\\t\\telse:\\n\\t\\t\\tr = mid - 1\\n\\treturn -1\\n\\ndef bs(arr, l, r, x):\\n\\tif x < arr[0]:\\n\\t\\treturn -1\\n\\tif x > arr[len(arr) - 1]:\\n\\t\\treturn len(arr)\\n\\twhile l <= r:\\n\\t\\tmid = l + (r - l) // 2\\n\\t\\tif arr[mid] <= x:\\n\\t\\t\\tl = mid + 1\\n\\t\\telif arr[mid] > x:\\n\\t\\t\\tr = mid - 1\\n\\tpos = l\\n\\twhile pos < len(arr) and arr[pos] <= x:\\n\\t\\tpos += 1\\n\\treturn pos\\n\\ndef solve():\\n\\ts = input()\\n\\tn = len(s)\\n\\tpre = [0] * n\\n\\tpresum = [0] * n\\n\\tsuf = [0] * n\\n\\tsufsum = [0] * n\\n\\tten = [0] * n\\n\\ttensum = [0] * n\\n\\tpresum[0] = pre[0] = int(s[0])\\n\\tsufsum[n - 1] = suf[n - 1] = int(s[n - 1])\\n\\tten[0] = 1\\n\\ttensum[0] = 0\\n\\tfor i in range(1, n):\\n\\t\\tpre[i] = (pre[i - 1] * 10 % mod + int(s[i])) % mod\\n\\t\\tpresum[i] = (presum[i - 1] + pre[i]) % mod\\n\\tp = 10\\n\\tfor i in range(n - 2, -1, -1):\\n\\t\\tsuf[i] = (int(s[i]) * p % mod + suf[i + 1]) % mod\\n\\t\\tsufsum[i] = (sufsum[i + 1] + suf[i]) % mod\\n\\t\\tp = p * 10 % mod\\n\\tfor i in range(1, n):\\n\\t\\tten[i] = ten[i - 1] * 10 % mod\\n\\t\\ttensum[i] = (tensum[i - 1] + ten[i]) % mod\\n\\tif n == 1:\\n\\t\\tprint(0)\\n\\t\\treturn\\n\\tif n == 2:\\n\\t\\tprint(int(s[0]) + int(s[1]))\\n\\t\\treturn\\n\\tans = 0\\n\\tans = (ans + sufsum[1]) % mod\\n\\tans = (ans + presum[n - 2]) % mod\\n\\tfor i in range(1, n - 1):\\n\\t\\ttemp = pre[i - 1] * tensum[n - i - 1] % mod\\n\\t\\ttemp = (temp + sufsum[i + 1]) % mod\\n\\t\\tans = (ans + temp) % mod\\n\\tprint(ans % mod)\\nsolve()\\n\", \"d = list(input())\\nn = len(d)\\nd = [0] + list(map(int, d)) + [0]\\np = [0 for i in range(n + 2)]\\ns = [0 for i in range(n + 2)]\\nMOD = 1000000007\\ncur = 0\\nfor i in range(1, n + 1):\\n\\tcur = (cur * 10 + d[i]) % MOD\\n\\tp[i] = cur\\np10 = 1\\ncur = 0\\nfor i in range(n, 0, -1):\\n\\tcur = (cur + d[i] * p10) % MOD\\n\\tp10 = p10 * 10 % MOD\\n\\ts[i] = cur\\nfor i in range(n, 0, -1):\\n\\ts[i] = (s[i] + s[i + 1]) % MOD\\nfor i in range(1, n + 1):\\n\\tp[i] = (p[i - 1] + p[i]) % MOD\\np10 = 1\\nans = 0\\nfor i in range(n - 1, -1, -1):\\n\\tans = (ans + p10 * p[i]) % MOD\\n\\tp10 = p10 * 10 % MOD\\nfor i in range(2, n + 1):\\n\\tans = (ans + s[i]) % MOD\\nprint(ans)\\n\", \"arr = [int(x) for x in input()]\\nMOD = int(1000000000.0 + 7)\\nn = len(arr)\\npow10 = [1]\\nfor i in range(1, n + 1):\\n\\tpow10.append(pow10[-1] * 10 % MOD)\\nsuffixes = [0]\\nfor i in range(1, n + 1):\\n\\tsuffixes.append((suffixes[-1] + i * pow10[i - 1]) % MOD)\\nprefixes = [0]\\ntriangle = 1\\nfor i in range(1, n + 1):\\n\\tprefixes.append(prefixes[-1] + triangle)\\n\\ttriangle += 1\\nsuffixes = suffixes[::-1]\\nans = 0\\nfor (i, x) in enumerate(arr):\\n\\tans += suffixes[i + 1] * x\\n\\tans += prefixes[i] * x * pow10[n - i - 1]\\n\\tans %= MOD\\nprint(ans % MOD)\\n\", \"import sys, os, io\\n\\ndef rs():\\n\\treturn sys.stdin.readline().rstrip()\\n\\ndef ri():\\n\\treturn int(sys.stdin.readline())\\n\\ndef ria():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n\\ndef ws(s):\\n\\tsys.stdout.write(s + '\\\\n')\\n\\ndef wi(n):\\n\\tsys.stdout.write(str(n) + '\\\\n')\\n\\ndef wia(a):\\n\\tsys.stdout.write(' '.join([str(x) for x in a]) + '\\\\n')\\nimport math, datetime, functools, itertools, operator, bisect, fractions, statistics\\nfrom collections import deque, defaultdict, OrderedDict, Counter\\nfrom fractions import Fraction\\nfrom decimal import Decimal\\nfrom sys import stdout\\n\\ndef main():\\n\\tstarttime = datetime.datetime.now()\\n\\tif os.path.exists('input.txt'):\\n\\t\\tsys.stdin = open('input.txt', 'r')\\n\\t\\tsys.stdout = open('output.txt', 'w')\\n\\tmod = 1000000007\\n\\tz1 = [1]\\n\\tz2 = [0]\\n\\tv = 0\\n\\tfor i in range(100005):\\n\\t\\tk = z1[-1]\\n\\t\\tz1.append(k * 10 % mod)\\n\\t\\tv += k * (i + 1) % mod\\n\\t\\tz2.append(v % mod)\\n\\tfor _ in range(1):\\n\\t\\ts = rs()\\n\\t\\tn = len(s)\\n\\t\\tans = 0\\n\\t\\tfor i in range(n):\\n\\t\\t\\tcurr = ord(s[i]) - 48\\n\\t\\t\\tind = i + 1\\n\\t\\t\\tleftsideofind = i\\n\\t\\t\\trightsideofind = n - i - 1\\n\\t\\t\\tleftsidecontribution = curr * z1[rightsideofind] * (leftsideofind * (leftsideofind + 1) // 2 % mod)\\n\\t\\t\\trightsidecontribution = curr * z2[rightsideofind] % mod\\n\\t\\t\\tans += (leftsidecontribution + rightsidecontribution) % mod\\n\\t\\tprint(ans % mod)\\n\\tendtime = datetime.datetime.now()\\n\\ttime = (endtime - starttime).total_seconds() * 1000\\n\\tif os.path.exists('input.txt'):\\n\\t\\tprint('Time:', time, 'ms')\\n\\nclass FastReader(io.IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, fd, chunk_size=1024 * 8):\\n\\t\\tself._fd = fd\\n\\t\\tself._chunk_size = chunk_size\\n\\t\\tself.buffer = io.BytesIO()\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self, size=-1):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\nclass FastWriter(io.IOBase):\\n\\n\\tdef __init__(self, fd):\\n\\t\\tself._fd = fd\\n\\t\\tself.buffer = io.BytesIO()\\n\\t\\tself.write = self.buffer.write\\n\\n\\tdef flush(self):\\n\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass FastStdin(io.IOBase):\\n\\n\\tdef __init__(self, fd=0):\\n\\t\\tself.buffer = FastReader(fd)\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n\\nclass FastStdout(io.IOBase):\\n\\n\\tdef __init__(self, fd=1):\\n\\t\\tself.buffer = FastWriter(fd)\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.flush = self.buffer.flush\\nsys.stdin = FastStdin()\\nsys.stdout = FastStdout()\\nmain()\\n\", \"n = input()\\nmod = 10 ** 9 + 7\\nans = 0\\nmul1 = 0\\nmul2 = 1\\nfor i in range(len(n) - 1, -1, -1):\\n\\tans += int(n[i]) * (mul1 + mul2 * i * (i + 1) // 2)\\n\\tans %= mod\\n\\tmul1 += (len(n) - i) * mul2\\n\\tmul1 %= mod\\n\\tmul2 *= 10\\n\\tmul2 %= mod\\nprint(ans)\\n\", \"M = 1000000007\\ns = input()\\nn = len(s)\\nval = [0, 1]\\npower = [1]\\nstart = 1\\nfor i in range(1, n):\\n\\tap = (i + 1) * start * 10 % M\\n\\tval.append((ap + val[-1]) % M)\\n\\tpower.append(start * 10 % M)\\n\\tstart = start * 10 % M\\nans = 0\\nfor i in range(n):\\n\\tans = (ans + power[n - 1 - i] * int(s[i]) * i * (i + 1) // 2 % M) % M\\n\\tans = (ans + int(s[i]) * val[n - 1 - i] % M) % M\\nprint(ans)\\n\", \"S = list(input())\\nS = [int(elem) for elem in S]\\nn = len(S)\\nmod = int(1000000000.0 + 7)\\nr = [0] * (n + 1)\\nfor i in range(1, n + 1):\\n\\tif i == 1:\\n\\t\\tr[n + 1 - i] = S[-i]\\n\\telse:\\n\\t\\tr[n + 1 - i] = (r[n + 2 - i] + S[-i] * pow(10, i - 1, mod)) % mod\\nl = [0] * (n + 1)\\nfor i in range(1, n + 1):\\n\\tl[i] = (l[i - 1] * 10 + S[i - 1]) % mod\\n\\ndef inv(X):\\n\\treturn pow(X, mod - 2, mod)\\ninv9 = inv(9)\\nans = sum((l[k] * (pow(10, n - k, mod) - 1) * inv9 for k in range(1, n + 1))) + sum(((i - 1) * r[i] for i in range(2, n + 1)))\\nans %= mod\\nprint(ans)\\n\", \"MOD = 10 ** 9 + 7\\na = list(map(int, list(input())))\\nn = len(a)\\npow10 = [1] * (n + 1)\\npref = [1] + [0] * n\\nfor i in range(1, n + 1):\\n\\tpow10[i] = 10 * pow10[i - 1]\\n\\tpow10[i] %= MOD\\n\\tpref[i] = (pref[i - 1] + pow10[i] * (i + 1) % MOD) % MOD\\nret = 0\\nfor i in range(n):\\n\\tret += a[i] * pow10[n - i - 1] * (i * (i + 1) // 2)\\n\\tret %= MOD\\n\\tif n - i - 2 >= 0:\\n\\t\\tret += a[i] * pref[n - i - 2]\\n\\t\\tret %= MOD\\nprint(ret)\\n\", \"s = list(input())\\nn = len(s)\\nfor i in range(n):\\n\\ts[i] = int(s[i])\\nans = 0\\nmod = 10 ** 9 + 7\\nfor i in range(n):\\n\\ttmp = 0\\n\\ttmp = s[i] * pow(9, mod - 2, mod) * (n - i - 1) * pow(10, n - i - 1, mod)\\n\\ttmp %= mod\\n\\ttmp -= s[i] * pow(81, mod - 2, mod) * (pow(10, n - i - 1, mod) - 1)\\n\\ttmp %= mod\\n\\ttmp += (i * (i - 1) // 2 + i) * s[i] * pow(10, n - i - 1, mod)\\n\\ttmp %= mod\\n\\tans += tmp\\n\\tans %= mod\\nprint(ans)\\n\", \"M = 10 ** 9 + 7\\n\\ndef power(x, y):\\n\\tans = 1\\n\\twhile y > 0:\\n\\t\\tif y % 2 == 1:\\n\\t\\t\\tans = ans * x % M\\n\\t\\ty = y // 2\\n\\t\\tx = x * x % M\\n\\treturn ans % M\\nn = input()\\nk = len(n)\\ni = k - 1\\ncnt = 0\\nans = 0\\nprev = 0\\nwhile i > -1:\\n\\tcnt += 1\\n\\trem = k - cnt\\n\\tnow = rem * (rem + 1) % M\\n\\tu = now * power(2, M - 2) % M\\n\\ttotal = power(10, cnt - 1) * int(n[i]) % M\\n\\tsom = total * u % M\\n\\tsom = (som + prev * int(n[i]) % M) % M\\n\\tans = (ans + som) % M\\n\\tprev = (prev + cnt * power(10, cnt - 1) % M) % M\\n\\ti -= 1\\nprint(ans)\\n\", \"import sys\\n[n] = [int(i) for i in input().split()]\\ndigits = [int(i) for i in str(n)]\\ndigits.reverse()\\nl = len(digits)\\nmod = 10 ** 9 + 7\\ninv = 123456791\\ninv2 = 500000004\\nans = 0\\n\\ndef exp(base, nn):\\n\\tif nn == 0:\\n\\t\\treturn 1\\n\\telif nn == 1:\\n\\t\\treturn base\\n\\telif nn % 2 == 0:\\n\\t\\ta = exp(base, nn // 2)\\n\\t\\treturn a * a % mod\\n\\telse:\\n\\t\\ta = exp(base, nn // 2)\\n\\t\\treturn a * a % mod * base % mod\\n\\ndef rhs(nn):\\n\\ti1 = (exp(10, nn) * (9 * nn - 1) + 1) % mod\\n\\treturn i1 * inv % mod\\nfor i in range(len(digits)):\\n\\td = digits[i]\\n\\trr = rhs(i) % mod\\n\\tll = (l - i) * (l - i - 1) // 2 % mod\\n\\tll = ll * exp(10, i) % mod\\n\\tans += d * (rr + ll) % mod\\n\\tans = ans % mod\\nprint(ans)\\n\", \"import sys\\nfrom collections import deque\\nfrom math import ceil, sqrt, gcd, factorial\\nfrom bisect import bisect_right, bisect_left\\nmod = 1000000007\\nINF = 10 ** 18\\nNINF = -INF\\n\\ndef I():\\n\\treturn int(input())\\n\\ndef MAP():\\n\\treturn map(int, input().split())\\n\\ndef LIST():\\n\\treturn list(map(int, input().split()))\\n\\ndef modi(x):\\n\\treturn pow(x, mod - 2, mod)\\n\\ndef lcm(x, y):\\n\\treturn x * y // gcd(x, y)\\n\\ndef write(l):\\n\\tfor i in l:\\n\\t\\tprint(i, end=' ')\\n\\tprint()\\ns = input()\\nans = 0\\nn = len(s)\\ni = modi(9)\\nfor x in range(n):\\n\\tsx = int(s[x])\\n\\tt = x * (x + 1) // 2 % mod\\n\\tans = (ans + sx * pow(10, n - x - 1, mod) * t % mod) % mod\\n\\tf = n - x - 1\\n\\tt1 = f * pow(10, f, mod) % mod\\n\\tt2 = (pow(10, f, mod) - 1) % mod\\n\\tt2 = t2 * i % mod\\n\\ttemp = (t1 - t2) % mod\\n\\ttemp = temp * i % mod\\n\\tans = (ans + temp * sx) % mod\\nprint(ans)\\n\"]"