"[\"hist = [0] * 1000005\\n\\ndef solve(n, s):\\n\\ttot = 0\\n\\tcur = 0\\n\\ti = 0\\n\\twhile i < n:\\n\\t\\tif s[i] == '0':\\n\\t\\t\\ttot += cur\\n\\t\\telse:\\n\\t\\t\\tl = i\\n\\t\\t\\tr = i\\n\\t\\t\\twhile r + 1 < n and s[r + 1] == '1':\\n\\t\\t\\t\\tr += 1\\n\\t\\t\\tfor x in range(r - l + 1):\\n\\t\\t\\t\\tcur += l + x + 1 - hist[x]\\n\\t\\t\\t\\ttot += cur\\n\\t\\t\\t\\thist[x] = r - x + 1\\n\\t\\t\\ti = r\\n\\t\\ti += 1\\n\\treturn tot\\nn = int(input())\\ns = input()\\nprint(solve(n, s))\\n\", \"N = int(input())\\nS = input()\\np = 0\\nb = [0 for i in range(N + 1)]\\na = 0\\ns = 0\\nfor c in S:\\n\\tif c == '0':\\n\\t\\tp = 0\\n\\t\\tb[0] += 1\\n\\telif p == 0:\\n\\t\\tp = 1\\n\\t\\ts += b[0] + 1\\n\\t\\tb[1] += b[0]\\n\\t\\tb[0] = 0\\n\\t\\tb[1] += 1\\n\\telse:\\n\\t\\tp += 1\\n\\t\\ts += b[p - 1] + p - 1\\n\\t\\tb[p] += b[p - 1]\\n\\t\\tb[p - 1] = 1\\n\\ta += s\\nprint(a)\\n\", \"from sys import stdin\\nn = int(stdin.readline())\\ns = stdin.readline().strip()\\ntotal = 0\\ncrnt = 0\\nhist = [0] * n\\ni = 0\\nwhile i < n:\\n\\tif s[i] == '0':\\n\\t\\ttotal += crnt\\n\\telse:\\n\\t\\tl = i\\n\\t\\tr = i\\n\\t\\twhile r + 1 < n and s[r + 1] == '1':\\n\\t\\t\\tr += 1\\n\\t\\tfor j in range(r - l + 1):\\n\\t\\t\\tcrnt += l + j + 1 - hist[j]\\n\\t\\t\\ttotal += crnt\\n\\t\\t\\thist[j] = r - j + 1\\n\\t\\ti = r\\n\\ti += 1\\nprint(total)\\n\", \"n = int(input())\\na = map(int, input())\\nacc = 0\\nback = 0\\ntop = 0\\ncur = 0\\ns = []\\nfor (i, x) in enumerate(a):\\n\\tif x == 0:\\n\\t\\tcur = 0\\n\\telse:\\n\\t\\tif cur > 0:\\n\\t\\t\\ts.pop()\\n\\t\\tcur += 1\\n\\t\\tif cur >= top:\\n\\t\\t\\ttop = cur\\n\\t\\t\\tback = (cur + 1) * cur // 2 + (i - cur + 1) * cur\\n\\t\\t\\ts = [(cur, i)]\\n\\t\\telse:\\n\\t\\t\\tback += i - (s[-1][1] - cur + 1)\\n\\t\\t\\tif cur >= s[-1][0]:\\n\\t\\t\\t\\ts.pop()\\n\\t\\t\\ts += [(cur, i)]\\n\\tacc += back\\nprint(acc)\\n\", \"from sys import stdin\\nimport sys\\nimport heapq\\n\\ndef bitadd(a, w, bit):\\n\\tx = a + 1\\n\\twhile x <= len(bit) - 1:\\n\\t\\tbit[x] += w\\n\\t\\tx += x & -1 * x\\n\\ndef bitsum(a, bit):\\n\\tret = 0\\n\\tx = a + 1\\n\\twhile x > 0:\\n\\t\\tret += bit[x]\\n\\t\\tx -= x & -1 * x\\n\\treturn ret\\nn = int(stdin.readline())\\ns = stdin.readline()[:-1]\\nbit = [0] * (n + 10)\\ndp = [0] * (n + 10)\\ny = 0\\nans = 0\\nfor i in range(n):\\n\\tif s[i] == '0':\\n\\t\\twhile y > 0:\\n\\t\\t\\tdp[y] += 1\\n\\t\\t\\tbitadd(y, y, bit)\\n\\t\\t\\ty -= 1\\n\\t\\tdp[0] += 1\\n\\telse:\\n\\t\\tbitadd(y, -1 * dp[y] * y, bit)\\n\\t\\tbitadd(y + 1, -1 * dp[y + 1] * (y + 1), bit)\\n\\t\\tdp[y + 1] += dp[y]\\n\\t\\tdp[y] = 0\\n\\t\\ty += 1\\n\\t\\tbitadd(y, dp[y] * y, bit)\\n\\tnow = bitsum(i, bit) + (1 + y) * y // 2\\n\\tans += now\\nprint(ans)\\n\", \"import math, sys\\nn = int(input())\\ns = input()\\ndp = [0] * (n + 1)\\ncurrlength = 0\\nd = [-1] * (n + 1)\\nfor i in range(n):\\n\\tif s[i] == '0':\\n\\t\\tdp[i + 1] = dp[i]\\n\\t\\tif currlength > 0:\\n\\t\\t\\tfor j in range(currlength):\\n\\t\\t\\t\\td[j + 1] = i - j - 1\\n\\t\\tcurrlength = 0\\n\\telse:\\n\\t\\tcurrlength += 1\\n\\t\\tnumsegs = i - d[currlength] - 1\\n\\t\\tdp[i + 1] = dp[i] + numsegs + 1\\nprint(sum(dp))\\n\", \"import sys, io, os\\nZ = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\\n\\ndef f(l, h):\\n\\tglobal L, S\\n\\tif h - l < 2:\\n\\t\\treturn L[l] % 2\\n\\tm = (l + h) // 2\\n\\tc = x = r = s = 0\\n\\td = 1\\n\\tfor i in range(m - 1, l - 1, -1):\\n\\t\\tif L[i] % 2:\\n\\t\\t\\tc += 1\\n\\t\\t\\tif c > x:\\n\\t\\t\\t\\tx = c\\n\\t\\t\\tif d:\\n\\t\\t\\t\\tr = c\\n\\t\\telse:\\n\\t\\t\\tc = d = 0\\n\\t\\tS[i] = x\\n\\t\\ts += x\\n\\tc = x = t = 0\\n\\td = e = 1\\n\\tp = m - max(1, r)\\n\\tw = S[m - 1]\\n\\tfor i in range(m, h):\\n\\t\\tif L[i] % 2:\\n\\t\\t\\tc += 1\\n\\t\\t\\tif c > x:\\n\\t\\t\\t\\tx = c\\n\\t\\t\\tif d:\\n\\t\\t\\t\\twhile S[p] < x + r:\\n\\t\\t\\t\\t\\tif p > l:\\n\\t\\t\\t\\t\\t\\tv = min(S[p - 1], x + r) - S[p]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tv = x + r - S[l]\\n\\t\\t\\t\\t\\t\\tS[l] = x + r\\n\\t\\t\\t\\t\\ts += v * (m - p)\\n\\t\\t\\t\\t\\tw += v\\n\\t\\t\\t\\t\\tif p > l:\\n\\t\\t\\t\\t\\t\\tp -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif e < r and w < x:\\n\\t\\t\\t\\t\\tw += 1\\n\\t\\t\\t\\t\\ts += e\\n\\t\\t\\t\\t\\te += 1\\n\\t\\t\\t\\twhile S[p] < x:\\n\\t\\t\\t\\t\\tif p > l:\\n\\t\\t\\t\\t\\t\\ts += (min(S[p - 1], x) - S[p]) * (m - p)\\n\\t\\t\\t\\t\\t\\tp -= 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ts += (x - S[l]) * (m - l)\\n\\t\\t\\t\\t\\t\\tS[l] = x\\n\\t\\telse:\\n\\t\\t\\tc = d = 0\\n\\t\\tt += s\\n\\treturn t + f(l, m) + f(m, h)\\nn = int(Z())\\nS = [0] * n\\nL = Z()\\nprint(f(0, n))\\n\", \"count = int(input())\\ns = input()\\na = []\\nadd = 0\\nfor i in s:\\n\\tif i == '0':\\n\\t\\ta.append(0)\\n\\t\\tadd = 0\\n\\telse:\\n\\t\\tadd += 1\\n\\t\\ta.append(add)\\nb = [0 for i in range(count)]\\nc = [0 for i in range(count + 1)]\\nguna = 0\\nfor i in range(count):\\n\\tguna = 0\\n\\tc[a[i]] += 1\\n\\tif a[i] == 0:\\n\\t\\tb[i] = 0\\n\\telse:\\n\\t\\tguna += a[i]\\n\\t\\tif c[a[i] - 1] > 0 and a[i] != 1:\\n\\t\\t\\tguna += c[a[i] - 1] - 1\\n\\t\\t\\tc[a[i]] += c[a[i] - 1] - 1\\n\\t\\t\\tc[a[i] - 1] = 1\\n\\t\\telif a[i] == 1:\\n\\t\\t\\tguna += c[a[i] - 1]\\n\\t\\t\\tc[a[i]] += c[a[i] - 1]\\n\\t\\t\\tc[a[i] - 1] = 0\\n\\t\\tb[i] = guna\\nss = 0\\nww = 0\\nfor i in range(count):\\n\\tss += b[i]\\n\\tww += ss\\nprint(ww)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\ndef prog():\\n\\tans = 0\\n\\tcurr_total = 0\\n\\tlast_loc_with_val = [-1] * 500001\\n\\tn = int(input())\\n\\ts = input().strip()\\n\\ti = 0\\n\\twhile i < n:\\n\\t\\tif s[i] == '0':\\n\\t\\t\\tans += curr_total\\n\\t\\telse:\\n\\t\\t\\tl = i\\n\\t\\t\\tr = i\\n\\t\\t\\twhile r + 1 < n and s[r + 1] == '1':\\n\\t\\t\\t\\tr += 1\\n\\t\\t\\tfor length in range(1, r - l + 2):\\n\\t\\t\\t\\tcurr_total += l + length - 1 - last_loc_with_val[length]\\n\\t\\t\\t\\tans += curr_total\\n\\t\\t\\t\\tlast_loc_with_val[length] = r - length + 1\\n\\t\\t\\ti = r\\n\\t\\ti += 1\\n\\tprint(ans)\\nprog()\\n\", \"import sys\\nreadline = sys.stdin.readline\\nN = int(readline())\\nA = list(map(int, readline().strip()))\\n\\ndef calc(l, r):\\n\\tm = (l + r) // 2\\n\\tif l + 1 == r:\\n\\t\\treturn A[l]\\n\\tif l + 2 == r:\\n\\t\\treturn 2 * (A[l] + A[l + 1])\\n\\tX = A[l:m][::-1]\\n\\tY = A[m:r]\\n\\tLX = len(X)\\n\\tLY = len(Y)\\n\\ta1 = [0] * LX\\n\\ta2 = [0] * LY\\n\\tpre = 1\\n\\tcnt = 0\\n\\tb1 = 0\\n\\tb2 = 0\\n\\tfor i in range(LX):\\n\\t\\tif X[i]:\\n\\t\\t\\tcnt += 1\\n\\t\\t\\tif pre:\\n\\t\\t\\t\\ta1[i] = cnt\\n\\t\\t\\t\\tb1 = cnt\\n\\t\\t\\telse:\\n\\t\\t\\t\\ta1[i] = max(a1[i - 1], cnt)\\n\\t\\telse:\\n\\t\\t\\tpre = 0\\n\\t\\t\\tcnt = 0\\n\\t\\t\\ta1[i] = a1[i - 1]\\n\\tpre = 1\\n\\tcnt = 0\\n\\tfor i in range(LY):\\n\\t\\tif Y[i]:\\n\\t\\t\\tcnt += 1\\n\\t\\t\\tif pre:\\n\\t\\t\\t\\ta2[i] = cnt\\n\\t\\t\\t\\tb2 = cnt\\n\\t\\t\\telse:\\n\\t\\t\\t\\ta2[i] = max(a2[i - 1], cnt)\\n\\t\\telse:\\n\\t\\t\\tpre = 0\\n\\t\\t\\tcnt = 0\\n\\t\\t\\ta2[i] = a2[i - 1]\\n\\tra = LX - 1\\n\\trb = LY - 1\\n\\ti = ra\\n\\tj = rb\\n\\tres = 0\\n\\tfor _ in range(LX + LY):\\n\\t\\tif a1[i] >= a2[j]:\\n\\t\\t\\ta = a1[i]\\n\\t\\t\\tif b1 + b2 <= a:\\n\\t\\t\\t\\tres += a * (j + 1)\\n\\t\\t\\telif a == b1:\\n\\t\\t\\t\\tres += b1 * b2 + b2 * (b2 + 1) // 2 + (b1 + b2) * (j + 1 - b2)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres += a * b2 + (b1 + b2 - a) * (b1 + b2 - a + 1) // 2 + (b1 + b2) * (j + 1 - b2)\\n\\t\\t\\ti -= 1\\n\\t\\t\\tb1 = min(b1, i + 1)\\n\\t\\telse:\\n\\t\\t\\ta = a2[j]\\n\\t\\t\\tif b1 + b2 <= a:\\n\\t\\t\\t\\tres += a * (i + 1)\\n\\t\\t\\telif a == b2:\\n\\t\\t\\t\\tres += b1 * b2 + b1 * (b1 + 1) // 2 + (b1 + b2) * (i + 1 - b1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres += a * b1 + (b1 + b2 - a) * (b1 + b2 - a + 1) // 2 + (b1 + b2) * (i + 1 - b1)\\n\\t\\t\\tj -= 1\\n\\t\\t\\tb2 = min(b2, j + 1)\\n\\t\\tif i == -1 or j == -1:\\n\\t\\t\\tbreak\\n\\treturn res + calc(l, m) + calc(m, r)\\nprint(calc(0, N))\\n\", \"n = int(input())\\ns = input()\\ntot = 0\\ncur = 0\\nhist = [0] * n\\ni = 0\\nwhile i < n:\\n\\tif s[i] == '0':\\n\\t\\ttot += cur\\n\\telse:\\n\\t\\tl = i\\n\\t\\tr = i\\n\\t\\twhile r + 1 < n and s[r + 1] == '1':\\n\\t\\t\\tr += 1\\n\\t\\tfor x in range(r - l + 1):\\n\\t\\t\\tcur += l + x + 1 - hist[x]\\n\\t\\t\\ttot += cur\\n\\t\\t\\thist[x] = r - x + 1\\n\\t\\ti = r\\n\\ti += 1\\nprint(tot)\\n\", \"n = int(input())\\ns = input()\\ni = 0\\nans = 0\\ncurr = 0\\nprev = [-1] * 500005\\nwhile i < n:\\n\\tif s[i] == '0':\\n\\t\\tans += curr\\n\\telse:\\n\\t\\tleft = i\\n\\t\\tright = i\\n\\t\\twhile right + 1 < n and s[right + 1] == '1':\\n\\t\\t\\tright += 1\\n\\t\\tfor j in range(right + 1 - left):\\n\\t\\t\\tcurr += left + j - prev[j]\\n\\t\\t\\tans += curr\\n\\t\\t\\tprev[j] = right - j\\n\\t\\ti = right\\n\\ti += 1\\nprint(ans)\\n\", \"import os\\nimport sys\\nfrom io import BytesIO, IOBase\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\n\\ndef RL():\\n\\treturn map(int, sys.stdin.readline().rstrip().split())\\n\\ndef RLL():\\n\\treturn list(map(int, sys.stdin.readline().rstrip().split()))\\n\\ndef N():\\n\\treturn int(input())\\n\\ndef print_list(l):\\n\\tprint(' '.join(map(str, l)))\\nn = N()\\ns = input()\\nres = 0\\nx = [-1] * (n + 1)\\nnow = 0\\nr = 0\\nwhile r < n:\\n\\tl = r\\n\\tif s[r] == '0':\\n\\t\\twhile r < n and s[r] == '0':\\n\\t\\t\\tr += 1\\n\\t\\tres += (r - l) * now\\n\\telse:\\n\\t\\twhile r < n and s[r] == '1':\\n\\t\\t\\tr += 1\\n\\t\\tfor k in range(1, r - l + 1):\\n\\t\\t\\tnow += l + k - 1 - x[k]\\n\\t\\t\\tres += now\\n\\t\\t\\tx[k] = r - k\\nprint(res)\\n\", \"class SegmentTree:\\n\\n\\tdef __init__(self, data, default=0, func=max):\\n\\t\\tself._default = default\\n\\t\\tself._func = func\\n\\t\\tself._len = len(data)\\n\\t\\tself._size = _size = 1 << (self._len - 1).bit_length()\\n\\t\\tself.data = [default] * (2 * _size)\\n\\t\\tself.data[_size:_size + self._len] = data\\n\\t\\tfor i in reversed(range(_size)):\\n\\t\\t\\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\\n\\n\\tdef __delitem__(self, idx):\\n\\t\\tself[idx] = self._default\\n\\n\\tdef __getitem__(self, idx):\\n\\t\\treturn self.data[idx + self._size]\\n\\n\\tdef __setitem__(self, idx, value):\\n\\t\\tidx += self._size\\n\\t\\tself.data[idx] = value\\n\\t\\tidx >>= 1\\n\\t\\twhile idx:\\n\\t\\t\\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\\n\\t\\t\\tidx >>= 1\\n\\n\\tdef __len__(self):\\n\\t\\treturn self._len\\n\\n\\tdef query(self, start, stop):\\n\\t\\tstart += self._size\\n\\t\\tstop += self._size\\n\\t\\tres_left = res_right = self._default\\n\\t\\twhile start < stop:\\n\\t\\t\\tif start & 1:\\n\\t\\t\\t\\tres_left = self._func(res_left, self.data[start])\\n\\t\\t\\t\\tstart += 1\\n\\t\\t\\tif stop & 1:\\n\\t\\t\\t\\tstop -= 1\\n\\t\\t\\t\\tres_right = self._func(self.data[stop], res_right)\\n\\t\\t\\tstart >>= 1\\n\\t\\t\\tstop >>= 1\\n\\t\\treturn self._func(res_left, res_right)\\n\\n\\tdef __repr__(self):\\n\\t\\treturn 'SegmentTree({0})'.format(self.data)\\nn = int(input())\\ns = input()\\npref = []\\ncurr = 0\\nfor c in s:\\n\\tif c == '1':\\n\\t\\tcurr += 1\\n\\telse:\\n\\t\\tcurr = 0\\n\\tpref.append(curr)\\nsuff = []\\ncurr = 0\\nfor c in s[::-1]:\\n\\tif c == '1':\\n\\t\\tcurr += 1\\n\\telse:\\n\\t\\tcurr = 0\\n\\tsuff.append(curr)\\nsuff.reverse()\\nst = SegmentTree(suff)\\nout = 0\\nadd = 0\\nfor i in range(n):\\n\\tif s[i] == '1':\\n\\t\\tlo = -1\\n\\t\\thi = i - pref[i] + 1\\n\\t\\twhile hi - lo > 1:\\n\\t\\t\\tt = (lo + hi) // 2\\n\\t\\t\\tif st.query(t, i - pref[i] + 1) >= pref[i]:\\n\\t\\t\\t\\tlo = t\\n\\t\\t\\telse:\\n\\t\\t\\t\\thi = t\\n\\t\\tadd += i - lo\\n\\tout += add\\nprint(out)\\n\", \"class F:\\n\\n\\tdef __init__(self, x):\\n\\t\\tself.b = x\\n\\t\\tfor i in range(len(x)):\\n\\t\\t\\tj = i | i + 1\\n\\t\\t\\tif j < len(x):\\n\\t\\t\\t\\tx[j] += x[i]\\n\\n\\tdef u(self, i, x):\\n\\t\\twhile i < len(self.b):\\n\\t\\t\\tself.b[i] += x\\n\\t\\t\\ti |= i + 1\\n\\n\\tdef f(self, k):\\n\\t\\ti = -1\\n\\t\\tfor d in reversed(range(len(self.b).bit_length())):\\n\\t\\t\\tr = i + (1 << d)\\n\\t\\t\\tif r < len(self.b) and k >= self.b[r]:\\n\\t\\t\\t\\ti = r\\n\\t\\t\\t\\tk -= self.b[i]\\n\\t\\treturn i + 1\\nZ = input\\nn = int(Z())\\nT = F([0] * n)\\nt = s = c = 0\\nL = [*map(int, Z().strip())]\\nfor i in range(n):\\n\\tif L[i] % 2:\\n\\t\\tc += 1\\n\\t\\tT.u(n - 1 - i, 1)\\n\\t\\tv = n - 1 - T.f(c)\\n\\t\\ts += i - v\\n\\t\\tif v >= 0:\\n\\t\\t\\tT.u(n - 1 - v, -1)\\n\\telse:\\n\\t\\tc = 0\\n\\tt += s\\nprint(t)\\n\", \"n = int(input())\\nl = map(int, input())\\n(c, s, w, p) = ([0] * (n + 3), 0, 0, 0)\\nfor i in l:\\n\\tif i == 1:\\n\\t\\tp += 1\\n\\t\\ts += c[p - 1] + max(1, p - 1)\\n\\t\\tc[p] += c[p - 1]\\n\\t\\tc[p - 1] = 0\\n\\t\\tc[max(1, p - 1)] += 1\\n\\telse:\\n\\t\\tp = 0\\n\\t\\tc[0] += 1\\n\\tw += s\\nprint(w)\\n\", \"n = int(input())\\ns = input()\\n(res, now, r) = (0, 0, 0)\\nx = [-1] * (n + 1)\\nwhile r < n:\\n\\tl = r\\n\\tif s[r] == '0':\\n\\t\\twhile r < n and s[r] == '0':\\n\\t\\t\\tr += 1\\n\\t\\tres += (r - l) * now\\n\\telse:\\n\\t\\twhile r < n and s[r] == '1':\\n\\t\\t\\tr += 1\\n\\t\\tfor k in range(1, r - l + 1):\\n\\t\\t\\tnow += l + k - 1 - x[k]\\n\\t\\t\\tres += now\\n\\t\\t\\tx[k] = r - k\\nprint(res)\\n\", \"import sys\\ninput = sys.stdin.buffer.readline\\nn = int(input())\\ns = input().decode()[:n]\\n(one, rm, pos) = (0, [0] * n, [n] * (n + 1))\\nfor p in range(n - 1, -1, -1):\\n\\tu = s[p]\\n\\tif u == '1':\\n\\t\\tone += 1\\n\\t\\trm[p] = pos[one] - p\\n\\telif one:\\n\\t\\tfor i in range(one):\\n\\t\\t\\tpos[i + 1] = p + i + 1\\n\\t\\tone = 0\\n(sm, mx, one) = (0, 0, 0)\\nfor u in s:\\n\\tif u == '1':\\n\\t\\tone += 1\\n\\telse:\\n\\t\\tone = 0\\n\\tmx = max(mx, one)\\n\\tsm += mx\\nres = sm\\nfor u in rm:\\n\\tsm -= u\\n\\tres += sm\\nprint(res)\\n\", \"import os\\nimport sys\\nfrom io import BytesIO, IOBase\\n\\nclass SegmentTree:\\n\\n\\tdef __init__(self, data, default=0, func=max):\\n\\t\\tself._default = default\\n\\t\\tself._func = func\\n\\t\\tself._len = len(data)\\n\\t\\tself._size = _size = 1 << (self._len - 1).bit_length()\\n\\t\\tself.data = [default] * (2 * _size)\\n\\t\\tself.data[_size:_size + self._len] = data\\n\\t\\tfor i in reversed(range(_size)):\\n\\t\\t\\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\\n\\n\\tdef __delitem__(self, idx):\\n\\t\\tself[idx] = self._default\\n\\n\\tdef __getitem__(self, idx):\\n\\t\\treturn self.data[idx + self._size]\\n\\n\\tdef __setitem__(self, idx, value):\\n\\t\\tidx += self._size\\n\\t\\tself.data[idx] = value\\n\\t\\tidx >>= 1\\n\\t\\twhile idx:\\n\\t\\t\\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\\n\\t\\t\\tidx >>= 1\\n\\n\\tdef __len__(self):\\n\\t\\treturn self._len\\n\\n\\tdef query(self, start, stop):\\n\\t\\tstart += self._size\\n\\t\\tstop += self._size\\n\\t\\tres_left = res_right = self._default\\n\\t\\twhile start < stop:\\n\\t\\t\\tif start & 1:\\n\\t\\t\\t\\tres_left = self._func(res_left, self.data[start])\\n\\t\\t\\t\\tstart += 1\\n\\t\\t\\tif stop & 1:\\n\\t\\t\\t\\tstop -= 1\\n\\t\\t\\t\\tres_right = self._func(self.data[stop], res_right)\\n\\t\\t\\tstart >>= 1\\n\\t\\t\\tstop >>= 1\\n\\t\\treturn self._func(res_left, res_right)\\n\\n\\tdef __repr__(self):\\n\\t\\treturn 'SegmentTree({0})'.format(self.data)\\n\\ndef main():\\n\\tn = int(input())\\n\\ts = input()\\n\\tlastZero = -1\\n\\tcontiguousOneAfter = [0] * n\\n\\tcontiguousOneBefore = [0] * n\\n\\tfor i in range(n):\\n\\t\\tif s[i] == '0':\\n\\t\\t\\tcnt = 1\\n\\t\\t\\tfor j in range(i - 1, lastZero, -1):\\n\\t\\t\\t\\tcontiguousOneAfter[j] = cnt\\n\\t\\t\\t\\tcnt += 1\\n\\t\\t\\tlastZero = i\\n\\tif s[-1] == '1':\\n\\t\\tcnt = 1\\n\\t\\tfor j in range(n - 1, lastZero, -1):\\n\\t\\t\\tcontiguousOneAfter[j] = cnt\\n\\t\\t\\tcnt += 1\\n\\tprimAns = 0\\n\\tcurMax = 0\\n\\tcurCnt = 0\\n\\tfor i in range(n):\\n\\t\\tif s[i] == '1':\\n\\t\\t\\tcurCnt += 1\\n\\t\\tif s[i] == '0':\\n\\t\\t\\tcurCnt = 0\\n\\t\\tif curCnt > curMax:\\n\\t\\t\\tcurMax = curCnt\\n\\t\\tcontiguousOneBefore[i] = curCnt\\n\\t\\tprimAns += curMax\\n\\twhenBlocked = [0] * n\\n\\tsegTree = SegmentTree([0] * (n + 1), 0)\\n\\tfor i in range(n - 1, -1, -1):\\n\\t\\tif s[i] == '1':\\n\\t\\t\\twhenBlocked[i] = n - segTree.query(contiguousOneAfter[i], n + 1)\\n\\t\\t\\tif contiguousOneBefore[i] == 1:\\n\\t\\t\\t\\tfor j in range(i, i + contiguousOneAfter[i] + 1):\\n\\t\\t\\t\\t\\tif n - j >= 0 and n - j <= n and (j < n):\\n\\t\\t\\t\\t\\t\\tsegTree.__setitem__(contiguousOneBefore[j], n - j)\\n\\tans = primAns\\n\\tfor i in range(n):\\n\\t\\tif s[i] == '1':\\n\\t\\t\\tprimAns -= whenBlocked[i] - i\\n\\t\\tans += primAns\\n\\tprint(ans)\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nmain()\\n\", \"n = int(input())\\ns = input()\\nf = [n + 1] * (n + 1)\\n(cur, total, ans) = (0, 0, 0)\\nfor i in range(n - 1, -1, -1):\\n\\tif s[i] == '1':\\n\\t\\tcur += 1\\n\\t\\ttotal += f[cur] - i - 1\\n\\telse:\\n\\t\\twhile cur:\\n\\t\\t\\tf[cur] = i + 1 + cur\\n\\t\\t\\tcur -= 1\\n\\tans += total\\nprint(ans)\\n\", \"class F:\\n\\n\\tdef __init__(self, x):\\n\\t\\tself.bit = x\\n\\t\\tfor i in range(len(x)):\\n\\t\\t\\tj = i | i + 1\\n\\t\\t\\tif j < len(x):\\n\\t\\t\\t\\tx[j] += x[i]\\n\\n\\tdef upd(self, idx, x):\\n\\t\\twhile idx < len(self.bit):\\n\\t\\t\\tself.bit[idx] += x\\n\\t\\t\\tidx |= idx + 1\\n\\n\\tdef find(self, k):\\n\\t\\tidx = -1\\n\\t\\tfor d in reversed(range(len(self.bit).bit_length())):\\n\\t\\t\\tright_idx = idx + (1 << d)\\n\\t\\t\\tif right_idx < len(self.bit) and k >= self.bit[right_idx]:\\n\\t\\t\\t\\tidx = right_idx\\n\\t\\t\\t\\tk -= self.bit[idx]\\n\\t\\treturn idx + 1\\nimport sys, io, os\\nZ = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\\nn = int(Z())\\nT = F([0] * n)\\nt = s = c = 0\\nL = Z()\\nfor i in range(n):\\n\\tif L[i] % 2:\\n\\t\\tc += 1\\n\\t\\tT.upd(n - 1 - i, 1)\\n\\t\\tv = n - 1 - T.find(c)\\n\\t\\ts += i - v\\n\\t\\tif v >= 0:\\n\\t\\t\\tT.upd(n - 1 - v, -1)\\n\\telse:\\n\\t\\tc = 0\\n\\tt += s\\nprint(t)\\n\"]"